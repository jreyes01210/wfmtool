<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>AI Forecasting Tool</title>
<meta content="Upload historical calls &amp; AHT; generate forecasts and staffing using Erlang C" name="description"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.13.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/arima@1.0.9/build/arima.min.js"></script>
<style>
    /* =========================
       High-end Calm Tech UI theme (LIGHT / Calm / High-end)
       UI only — no logic changes
       ========================= */

    :root{
      --bg0: #f6f8fc;
      --bg1: #eef2ff;
      --bg2: #f8fafc;

      --card: rgba(255,255,255,.78);
      --card2: rgba(255,255,255,.92);
      --card-border: rgba(15,23,42,.10);

      --text: #0f172a;
      --muted: rgba(15,23,42,.70);
      --muted2: rgba(15,23,42,.58);

      --accent: #14b8a6;
      --accent2:#3b82f6;
      --accent3:#8b5cf6;
      --ok:#16a34a;

      --shadow: 0 18px 48px rgba(2,6,23,.10);
      --shadow2: 0 28px 80px rgba(2,6,23,.14);

      --radius: 18px;
      --radius2: 22px;

      --ring: 0 0 0 .18rem rgba(59,130,246,.18);
      --ring2: 0 0 0 .18rem rgba(20,184,166,.14);
    }

    body{
      padding: 14px;
      background:
        radial-gradient(900px 520px at 10% 0%, rgba(59,130,246,.10), transparent 60%),
        radial-gradient(900px 520px at 95% 10%, rgba(139,92,246,.10), transparent 60%),
        radial-gradient(860px 520px at 55% 110%, rgba(20,184,166,.10), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg2) 60%, #ffffff);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
    }

    .container{ max-width: 1260px; }

    .app-topbar{
      position: sticky;
      top: 0;
      z-index: 100;
      margin-bottom: 10px;
      border-radius: var(--radius2);
      border: 1px solid rgba(15,23,42,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.72));
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      overflow: hidden;
    }
    .app-topbar::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(1200px 220px at 12% 0%, rgba(59,130,246,.16), transparent 60%),
        radial-gradient(1000px 260px at 95% 0%, rgba(20,184,166,.14), transparent 60%),
        radial-gradient(900px 260px at 65% 20%, rgba(139,92,246,.12), transparent 62%);
      opacity:.95;
      pointer-events:none;
      animation: headerGlow 10s ease-in-out infinite alternate;
    }
    @keyframes headerGlow{
      from{ transform: translateY(0px); opacity:.88; }
      to{ transform: translateY(-6px); opacity:1; }
    }
    .app-header{
      position: relative;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
    }
    .app-title{
      font-weight: 900;
      letter-spacing: -0.03em;
      font-size: 1.45rem;
      margin: 0;
      background: linear-gradient(90deg, #0f172a, rgba(59,130,246,.95), rgba(20,184,166,.92));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 10px 30px rgba(2,6,23,.08);
    }
    .app-sub{
      color: var(--muted);
      font-size: .82rem;
      margin-top: 2px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(15,23,42,.10);
      background: rgba(255,255,255,.75);
      box-shadow: 0 10px 26px rgba(2,6,23,.08);
      font-size: .78rem;
      color: rgba(15,23,42,.72);
      white-space: nowrap;
    }
    .dot{
      width: 8px; height: 8px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, rgba(20,184,166,1), rgba(59,130,246,.95));
      box-shadow: 0 0 0 3px rgba(20,184,166,.12);
    }

    pre{white-space:pre-wrap}
    .small-muted{font-size:0.80rem;color:var(--muted)}
    code{
      color: rgba(15,23,42,.92);
      background: rgba(59,130,246,.10);
      padding:2px 6px;
      border-radius:10px;
      border:1px solid rgba(59,130,246,.16)
    }

    .card{
      margin-bottom: 10px;
      border: 1px solid var(--card-border) !important;
      background: linear-gradient(180deg, var(--card2), var(--card)) !important;
      border-radius: var(--radius) !important;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow: hidden;
    }
    .card:hover{
      border-color: rgba(59,130,246,.18) !important;
      box-shadow: 0 22px 70px rgba(2,6,23,.12);
      transform: translateY(-1px);
      transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
    }
    .card-soft{ padding: 10px !important; }

    .section-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .section-title{
      display:flex;
      align-items:center;
      gap:10px;
      margin: 0;
      font-size: .98rem;
      font-weight: 850;
      letter-spacing: -0.01em;
      color: rgba(15,23,42,.94);
    }
    .section-ico{
      width: 28px;
      height: 28px;
      border-radius: 10px;
      border: 1px solid rgba(15,23,42,.10);
      background:
        radial-gradient(16px 16px at 30% 30%, rgba(20,184,166,.18), transparent 60%),
        radial-gradient(18px 18px at 70% 70%, rgba(59,130,246,.16), transparent 60%),
        rgba(255,255,255,.75);
      box-shadow: 0 12px 26px rgba(2,6,23,.08);
      flex: 0 0 auto;
    }
    .section-actions{
      display:flex;
      align-items:center;
      gap: 8px;
      flex: 0 0 auto;
    }
    .toggle-btn{
      border-radius: 12px !important;
      border: 1px solid rgba(15,23,42,.12) !important;
      background: rgba(255,255,255,.80) !important;
      color: rgba(15,23,42,.88) !important;
      font-size: .74rem !important;
      padding: .25rem .55rem !important;
      line-height: 1.15;
      transition: transform .14s ease, box-shadow .14s ease, filter .14s ease;
    }
    .toggle-btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 14px 28px rgba(2,6,23,.10);
      filter: saturate(1.03);
    }
    .toggle-btn:active{ transform: translateY(0px) scale(.99); box-shadow: none; }

    .card label{ font-size: .80rem; color: var(--muted2); }
    .form-control, .form-select{
      border-radius: 12px !important;
      border: 1px solid rgba(15,23,42,.14) !important;
      background: rgba(255,255,255,.92) !important;
      color: rgba(15,23,42,.92) !important;
      box-shadow: none !important;
    }
    .form-control::placeholder{ color: rgba(15,23,42,.42); }
    .form-control:focus, .form-select:focus{
      border-color: rgba(59,130,246,.40) !important;
      box-shadow: var(--ring) !important;
    }

    .btn{
      border-radius: 12px !important;
      transition: transform .14s ease, box-shadow .14s ease, filter .14s ease;
    }
    .btn-compact{
      --bs-btn-padding-y: .22rem;
      --bs-btn-padding-x: .55rem;
      --bs-btn-font-size: .78rem;
      --bs-btn-border-radius: .75rem;
      line-height: 1.15;
    }
    .btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 16px 34px rgba(2,6,23,.12);
      filter: saturate(1.03);
    }
    .btn:active{ transform: translateY(0px) scale(.99); box-shadow: none; }

    .btn-primary{
      background: linear-gradient(90deg, rgba(59,130,246,.98), rgba(139,92,246,.92)) !important;
      border-color: rgba(59,130,246,.30) !important;
      color: #fff !important;
    }
    .btn-outline-primary{
      border-color: rgba(59,130,246,.38) !important;
      color: rgba(15,23,42,.92) !important;
      background: rgba(59,130,246,.08) !important;
    }
    .btn-outline-success{
      border-color: rgba(22,163,74,.34) !important;
      color: rgba(15,23,42,.92) !important;
      background: rgba(22,163,74,.08) !important;
    }
    .btn-outline-secondary{
      border-color: rgba(15,23,42,.18) !important;
      color: rgba(15,23,42,.86) !important;
      background: rgba(255,255,255,.72) !important;
    }
    .btn-outline-danger{
      border-color: rgba(220,38,38,.30) !important;
      color: rgba(15,23,42,.90) !important;
      background: rgba(220,38,38,.07) !important;
    }

    .status-pill{
      display:inline-block;
      padding:2px 9px;
      border-radius:999px;
      background: rgba(22,163,74,.10);
      color: rgba(15,23,42,.92);
      font-size: 12px;
      border: 1px solid rgba(22,163,74,.18);
    }

    .table-intraday-wrap{
      max-height: 300px;
      overflow:auto;
      border:1px solid rgba(15,23,42,.12);
      border-radius: 14px;
      background: rgba(255,255,255,.82);
    }
    .intraday-table{
      width: 100%;
      min-width: 0 !important;
      table-layout: fixed;
      font-size: .70rem;
      color: rgba(15,23,42,.92);
    }
    .intraday-table th{
      position: sticky;
      top: 0;
      background: rgba(241,245,249,.94);
      z-index: 2;
      backdrop-filter: blur(10px);
      font-size: .70rem;
      line-height: 1.05;
      padding: .18rem .25rem !important;
      white-space: nowrap;
      border-color: rgba(15,23,42,.12) !important;
      color: rgba(15,23,42,.72);
    }
    .intraday-table td{
      padding: .12rem .25rem !important;
      text-align: center;
      vertical-align: middle;
      border-color: rgba(15,23,42,.10) !important;
      color: rgba(15,23,42,.90);
      background: rgba(255,255,255,.70);
    }
    .intraday-table tr:nth-child(even) td{
      background: rgba(248,250,252,.85);
    }
    .intraday-table th:first-child,
    .intraday-table td:first-child{
      width: 86px;
      text-align: left;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .pct-input{
      width: 52px;
      min-width: 52px;
      padding: .10rem .20rem !important;
      font-size: .70rem;
      text-align: center;
      font-variant-numeric: tabular-nums;
      background: rgba(255,255,255,.92) !important;
      border-color: rgba(15,23,42,.16) !important;
      color: rgba(15,23,42,.92) !important;
    }
    .pct-disabled{
      background: rgba(15,23,42,.06) !important;
      color: rgba(15,23,42,.45) !important;
      border-color: rgba(15,23,42,.12) !important;
    }
    .intraday-table tbody td{ color:#000 !important; }
    .intraday-table tbody td input.pct-input{ color:#000 !important; }
    .intraday-table tbody td:first-child{ color:#000 !important; }
    .pct-disabled{ color: rgba(0,0,0,.45) !important; }

    .nav-tabs{ border-bottom: 1px solid rgba(15,23,42,.12); }
    .nav-tabs .nav-link{
      border-radius: 12px 12px 0 0;
      font-size: .84rem;
      color: rgba(15,23,42,.70);
      border-color: rgba(15,23,42,.12) rgba(15,23,42,.12) transparent;
      background: rgba(255,255,255,.70);
    }
    .nav-tabs .nav-link.active{
      color: rgba(15,23,42,.94);
      background: rgba(255,255,255,.92);
      border-color: rgba(59,130,246,.20) rgba(59,130,246,.14) transparent;
      box-shadow: 0 -12px 40px rgba(59,130,246,.08);
    }
    .tab-content{
      border: 1px solid rgba(15,23,42,.12);
      border-top: 0;
      border-radius: 0 14px 14px 14px;
      background: rgba(255,255,255,.80);
      backdrop-filter: blur(10px);
    }

    @keyframes fadeUp{ from{ opacity:0; transform: translateY(10px);} to{opacity:1; transform: translateY(0);} }
    .card{ animation: fadeUp .45s ease both; }
    .tab-pane{ animation: fadeUp .28s ease both; }

    .loading-overlay{
      position: fixed;
      inset: 0;
      background: rgba(15,23,42, 0.22);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 16px;
      animation: fadeUp .18s ease both;
      backdrop-filter: blur(6px);
    }
    .loading-card{
      background: linear-gradient(180deg, rgba(255,255,255,.94), rgba(255,255,255,.84));
      border-radius: 18px;
      padding: 16px 16px;
      width: min(460px, 92vw);
      box-shadow: var(--shadow2);
      border: 1px solid rgba(15,23,42,.12);
      backdrop-filter: blur(14px);
      color: rgba(15,23,42,.92);
    }
    #forecastChart{
      background: rgba(255,255,255,.84);
      border: 1px solid rgba(15,23,42,.12);
      border-radius: 14px;
      padding: 8px;
    }

    .forecast-wrap{
      border: 1px solid rgba(15,23,42,.12);
      border-radius: 14px;
      background: rgba(255,255,255,.82);
      overflow: hidden;
    }

    .forecast-summary{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      padding: 10px;
      border-bottom: 1px solid rgba(15,23,42,.10);
      background: rgba(248,250,252,.85);
    }
    .sum-card{
      flex: 1 1 220px;
      min-width: 210px;
      border: 1px solid rgba(15,23,42,.10);
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.76));
      padding: 10px 10px;
      box-shadow: 0 10px 26px rgba(2,6,23,.08);
      animation: fadeUp .28s ease both;
    }
    .sum-title{
      font-weight: 900;
      font-size: .86rem;
      letter-spacing: -0.01em;
      margin-bottom: 6px;
      color: rgba(15,23,42,.92);
    }
    .sum-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 10px;
      font-size: .80rem;
      color: var(--muted);
    }
    .sum-k{ color: var(--muted2); }
    .sum-v{ color: rgba(15,23,42,.94); font-weight: 900; text-align:right; font-variant-numeric: tabular-nums; }

    .forecast-table{
      width: 100%;
      table-layout: fixed;
      margin: 0;
      background: transparent;
      color: rgba(15,23,42,.92);
    }
    .forecast-table thead th{
      position: sticky;
      top: 0;
      z-index: 2;
      background: rgba(241,245,249,.96);
      backdrop-filter: blur(12px);
      font-size: .78rem;
      color: rgba(15,23,42,.72);
      letter-spacing: -0.01em;
      white-space: normal;
      word-break: break-word;
      padding: .34rem .40rem !important;
      text-align: center !important;
      border-bottom: 1px solid rgba(15,23,42,.12) !important;
      border-color: rgba(15,23,42,.12) !important;
    }
    .forecast-table tbody td{
      font-size: .82rem;
      padding: .30rem .40rem !important;
      text-align: center !important;
      vertical-align: middle;
      font-variant-numeric: tabular-nums;
      border-color: rgba(15,23,42,.10) !important;
    }
    .forecast-table tbody tr:nth-child(even){ background: rgba(248,250,252,.70); }
    .forecast-table tbody tr:hover{ background: rgba(59,130,246,.10); }

    .forecast-table .col-date{ width: 118px; }
    .forecast-table .col-day{ width: 60px; }
    .forecast-table .col-calls{ width: 120px; }
    .forecast-table .col-aht{ width: 92px; }
    .forecast-table .col-fte{ width: 120px; }

    .pill{
      display:inline-block;
      padding: 2px 9px;
      border-radius: 999px;
      border: 1px solid rgba(15,23,42,.12);
      background: rgba(255,255,255,.82);
      color: rgba(15,23,42,.74);
      font-size: .74rem;
      line-height: 1.2;
      white-space: nowrap;
    }

    .days-menu{
      max-height: 220px;
      overflow:auto;
      padding: .35rem .4rem;
      border-radius: 12px;
      background: rgba(255,255,255,.96);
      border: 1px solid rgba(15,23,42,.12);
      box-shadow: 0 18px 45px rgba(2,6,23,.14);
    }
    .days-item{
      display:flex;
      align-items:center;
      gap: .5rem;
      padding: .25rem .35rem;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      color: rgba(15,23,42,.86);
    }
    .days-item:hover{ background: rgba(59,130,246,.10); }
    .days-item input{ margin-top: 0; cursor: pointer; }

    #hoopList .hoop-entry{
      font-size: .76rem;
      line-height: 1.25;
      color: rgba(15,23,42,.86);
      background: rgba(255,255,255,.70);
      border-color: rgba(15,23,42,.12) !important;
    }
    #hoopList .hoop-entry strong{ font-size: .76rem; }
    #hoopList .hoop-entry .btn{ font-size: .70rem; }

    .event-badge{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: .74rem;
      border: 1px solid rgba(15,23,42,.12);
      background: rgba(255,255,255,.82);
      color: rgba(15,23,42,.74);
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .event-note{
      font-size: .78rem;
      color: var(--muted);
      margin-top: 6px;
    }
    .soft-panel{
      background: rgba(248,250,252,.70);
      border-color: rgba(15,23,42,.12) !important;
    }

    ::-webkit-scrollbar{ height: 10px; width: 10px; }
    ::-webkit-scrollbar-thumb{ background: rgba(15,23,42,.18); border-radius: 12px; }
    ::-webkit-scrollbar-track{ background: rgba(255,255,255,.55); }
  

/* =========================
   Clean layout (Tool28-like) — UI only, logic unchanged
   ========================= */
.glass-card{
  border: 1px solid rgba(15,23,42,.10);
  background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.78));
  border-radius: 20px;
  box-shadow: var(--shadow);
  backdrop-filter: blur(12px);
  padding: 14px;
}
.clean-tabs{
  border-bottom: 1px solid rgba(15,23,42,.12);
  gap: 8px;
  margin-bottom: 10px;
}
.clean-tabs .nav-link{
  border: none !important;
  border-radius: 12px !important;
  background: rgba(255,255,255,.70);
  color: rgba(15,23,42,.72);
  font-weight: 800;
  padding: 8px 12px;
}
.clean-tabs .nav-link.active{
  background: linear-gradient(90deg, rgba(59,130,246,.98), rgba(139,92,246,.92)) !important;
  color: #fff !important;
  box-shadow: 0 14px 38px rgba(59,130,246,.14);
}
.tab-content-area{ padding-top: 4px; }
.section-head{ display:none !important; } /* hide old mini-headers to reduce noise (content stays) */
.card{ margin-bottom: 0 !important; }
.card-soft{ padding: 0 !important; }


    /* AI LOADING OVERLAY (New Feature) */
    #ai-loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 9999;
      display: none; /* Controlled by JS */
      align-items: center;
      justify-content: center;
      flex-direction: column;
      transition: opacity 0.4s ease;
    }

    .orb-container {
      position: relative;
      width: 200px;
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .orb-core {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #6366f1, #a855f7, #ec4899);
      border-radius: 50%;
      filter: blur(15px);
      animation: orb-pulse 2s infinite ease-in-out;
    }

    .orb-ring {
      position: absolute;
      width: 140px;
      height: 140px;
      border: 2px solid rgba(99, 102, 241, 0.2);
      border-radius: 42% 58% 70% 30% / 45% 45% 55% 55%;
      animation: orb-rotate 4s infinite linear;
    }

    .orb-ring:nth-child(2) {
      width: 160px;
      height: 160px;
      border-color: rgba(168, 85, 247, 0.2);
      animation-direction: reverse;
      animation-duration: 6s;
    }

    .loader-text {
      margin-top: 30px;
      font-weight: 500;
      letter-spacing: 1px;
      color: var(--accent);
      text-transform: uppercase;
      font-size: 0.85rem;
      animation: text-shimmer 2s infinite;
    }

    @keyframes orb-pulse {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.2); opacity: 1; filter: blur(25px); }
    }

    @keyframes orb-rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes text-shimmer {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }


    .loader-text-animated{
      margin-top: 26px;
      font-weight: 800;
      font-size: 0.9rem;
      letter-spacing: .06em;
      color: rgba(15,23,42,.82);
      text-align: center;
      text-transform: uppercase;
      animation: fadePulse 1.8s infinite ease-in-out;
    }
    .dots span{
      display:inline-block;
      animation: dotBlink 1.4s infinite both;
      margin-left: 1px;
    }
    .dots span:nth-child(2){ animation-delay:.2s }
    .dots span:nth-child(3){ animation-delay:.4s }
    @keyframes dotBlink{
      0%{ opacity:.2 }
      20%{ opacity:1 }
      100%{ opacity:.2 }
    }
    @keyframes fadePulse{
      0%,100%{ opacity:.55 }
      50%{ opacity:1 }
    }
    
</style>
</head>
<body>
<div id="ai-loader-overlay">
    <div class="orb-container">
      <div class="orb-ring"></div>
      <div class="orb-ring"></div>
      <div class="orb-core"></div>
    </div>
    <div class="loader-text-animated" id="loader-status-text">
      Training AI Model<span class="dots"><span>.</span><span>.</span><span>.</span></span>
    </div>
</div>
<div class="container">
<div class="app-topbar">
<div class="app-header">
<div style="position:relative; z-index:1;">
<h1 class="app-title">AI Forecasting Tool</h1>
<div class="app-sub">Daily and Monthly Call + AHT + FTE Need Forecasting</div>
</div>
<div class="d-flex gap-2 align-items-center" style="position:relative; z-index:1;">
<div class="chip"><span class="dot"></span><span>JWoodman</span></div>
</div>
</div>
</div>
<div class="row g-3">
<div class="col-lg-4">
<div class="glass-card mb-3">
<div class="d-flex align-items-center gap-2 mb-3">
<span class="badge bg-primary-subtle text-primary rounded-circle" style="width:26px;height:26px;display:inline-flex;align-items:center;justify-content:center;font-weight:800;">1</span>
<div class="fw-bold" style="color:rgba(15,23,42,.92);">Data Source</div>
</div>
<ul class="nav nav-tabs clean-tabs" id="dataSourceTabs" role="tablist">
  <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#ds-daily" type="button">Daily</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#ds-intraday" type="button">Intraday</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#ds-api" type="button">API</button></li>
</ul>

<div class="tab-content tab-content-area p-2">
  <div class="tab-pane fade show active" id="ds-daily">
    <p class="small-muted">Required columns: <code>date</code>, <code>calls</code>, <code>aht_seconds</code>.</p>
    <input accept=".xlsx,.xls,.csv" class="form-control form-control-sm" id="fileInput" type="file"/>
    <div class="mt-2 small-muted" id="preview"></div>
  </div>

  <div class="tab-pane fade" id="ds-intraday">
    <p class="small-muted">Required columns: <code>day</code> (Monday–Sunday), <code>interval</code> (e.g., 8:30 AM), <code>calls</code>.</p>
    <input accept=".xlsx,.xls,.csv" class="form-control form-control-sm" id="intradayFileInput" type="file"/>
    <div class="mt-2 small-muted" id="intradayPreview"></div>
  </div>

  <div class="tab-pane fade" id="ds-api">
    <div class="small-muted">
      Connect to <strong>Genesys</strong>, <strong>Databricks</strong>, or any <strong>REST API</strong> via your proxy endpoint.
      (For security, browsers should not call Genesys/Databricks directly.)
    </div>

    <div class="border rounded p-2 mt-2 soft-panel">
      <div class="row g-2">
        <div class="col-12">
          <label class="small-muted mb-1">Source type</label>
          <select class="form-select form-select-sm" id="apiSourceType">
            <option value="genesys">Genesys Cloud</option>
            <option value="databricks">Databricks</option>
            <option value="rest" selected>Generic REST API</option>
          </select>
        </div>

        <div class="col-12">
          <label class="small-muted mb-1">Proxy / API URL</label>
          <input class="form-control form-control-sm" id="apiProxyUrl" placeholder="https://your-domain.com/forecast-data"/>
        </div>

        <div class="col-12">
          <label class="small-muted mb-1">Auth (optional)</label>
          <div class="row g-2">
            <div class="col-5">
              <select class="form-select form-select-sm" id="apiAuthType">
                <option value="none" selected>None</option>
                <option value="bearer">Bearer token</option>
                <option value="apikey">API key header</option>
              </select>
            </div>
            <div class="col-7">
              <input class="form-control form-control-sm" id="apiAuthValue" placeholder="token or key value"/>
            </div>
          </div>
          <div class="small-muted mt-1">Bearer uses <code>Authorization: Bearer ...</code>. API key uses <code>x-api-key: ...</code>.</div>
        </div>

        <div class="col-12">
          <label class="small-muted mb-1">Extra headers (optional JSON)</label>
          <textarea class="form-control form-control-sm" id="apiHeadersJson" rows="2" placeholder='{"x-tenant":"prod"}'></textarea>
        </div>

        <div class="col-12">
          <label class="small-muted mb-1">Expected response</label>
          <div class="small-muted">
            JSON with <code>daily</code> and optional <code>intraday</code>:
            <code>{"daily":[{"date":"YYYY-MM-DD","calls":123,"aht_seconds":456}], "intraday":[{"day":"Monday","interval":"8:30 AM","calls":10}]}</code>
          </div>
        </div>
      </div>

      <div class="d-flex gap-2 mt-2 flex-wrap">
        <button class="btn btn-outline-secondary btn-compact" id="apiTestBtn">Test</button>
        <button class="btn btn-outline-primary btn-compact" id="apiFetchBtn">Fetch Data</button>
        <button class="btn btn-outline-success btn-compact" id="apiSaveBtn">Save</button>
        <button class="btn btn-outline-danger btn-compact" id="apiClearBtn">Clear</button>
      </div>

      <div class="small-muted mt-2" id="apiMsg"></div>
    </div>
  </div>
</div>
</div>
<div class="glass-card mb-3">
<div class="d-flex align-items-center gap-2 mb-3">
<span class="badge bg-primary-subtle text-primary rounded-circle" style="width:26px;height:26px;display:inline-flex;align-items:center;justify-content:center;font-weight:800;">2</span>
<div class="fw-bold" style="color:rgba(15,23,42,.92);">Settings</div>
</div>
<ul class="nav nav-tabs clean-tabs" id="settingsTabsClean" role="tablist">
<li class="nav-item"><button class="nav-link active" data-bs-target="#st-forecast" data-bs-toggle="tab" type="button">Forecast</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#st-hoop" data-bs-toggle="tab" type="button">HOOP</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#st-erlang" data-bs-toggle="tab" type="button">Erlang</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#st-closed" data-bs-toggle="tab" type="button">Closed</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#st-volume" data-bs-toggle="tab" type="button">Volume %</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#st-events" data-bs-toggle="tab" type="button">Events</button></li>
 <li class="nav-item"><button class="nav-link" data-bs-target="#st-holidayintel" data-bs-toggle="tab" type="button">Holidays</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#st-openai" data-bs-toggle="tab" type="button">OpenAI</button></li>
</ul>
<div class="tab-content tab-content-area p-2">
<div class="tab-pane fade show active" id="st-forecast">
<label>Start date</label>
<input class="form-control form-control-sm mb-1" id="startDate" type="date"/>
<label>End date</label>
<input class="form-control form-control-sm mb-2" id="endDate" type="date"/>
<div class="form-check">
<input checked="" class="form-check-input" id="useHW" type="checkbox"/>
<label class="form-check-label small-muted">Time Series (Auto: HW / Holt / ARIMA / Prophet)</label>
</div>
<div class="form-check">
<input checked="" class="form-check-input" id="useRegression" type="checkbox"/>
<label class="form-check-label small-muted">Regression</label>
</div>
<div class="form-check">
<input checked="" class="form-check-input" id="useAI" type="checkbox"/>
<label class="form-check-label small-muted">AI (TF.js)</label>
</div>
<div class="form-check mb-2">
<input class="form-check-input" id="useOpenAI" type="checkbox"/>
<label class="form-check-label small-muted">OpenAI (via Proxy)</label>
</div>
<button class="btn btn-primary btn-compact" id="generateBtn">Generate</button>
<div class="small-muted mt-2" id="genMsg"></div>
<div class="small-muted mt-2" id="jsErr" style="display:none;color:#b91c1c;font-weight:700;"></div>
</div>
<div class="tab-pane fade" id="st-hoop">
<div class="collapse show" id="secHoop">
<div class="mt-2" id="hoopList"></div>
<button class="btn btn-sm btn-outline-primary btn-compact" id="addHoopBtn">Add HOOP / Business Days</button>
<div class="collapse mt-2" id="hoopEntryCollapse">
<div class="border rounded p-2 soft-panel">
<div class="small-muted mb-2">Select business days and hours (AM/PM). You can add multiple HOOP entries.</div>
<div class="row g-2">
<div class="col-12">
<label class="small-muted mb-1">Business days</label>
<div class="dropdown w-100">
<button aria-expanded="false" class="btn btn-outline-secondary btn-compact w-100 text-start" data-bs-toggle="dropdown" id="daysDropdownBtn" type="button">
                      Select days…
                    </button>
<div aria-labelledby="daysDropdownBtn" class="dropdown-menu w-100 days-menu" id="daysDropdownMenu"></div>
</div>
</div>
<div class="col-6">
<label class="small-muted mb-1">Start time</label>
<select class="form-select form-select-sm" id="hoopStartSel"></select>
</div>
<div class="col-6">
<label class="small-muted mb-1">End time</label>
<select class="form-select form-select-sm" id="hoopEndSel"></select>
</div>
</div>
<div class="d-flex gap-2 mt-2">
<button class="btn btn-outline-primary btn-compact" id="addHoopEntryBtn">Add Entry</button>
<button class="btn btn-outline-secondary btn-compact" id="clearHoopEntryBtn">Clear</button>
</div>
<div class="small-muted mt-2" id="hoopEntryMsg"></div>
</div>
</div>
<div class="d-flex gap-2 mt-2">
<button class="btn btn-outline-success btn-compact" id="saveHoopBtn">Save</button>
</div>
<div class="small-muted mt-2" id="hoopMsg"></div>
</div>
</div>
<div class="tab-pane fade" id="st-erlang">
<div class="collapse show" id="secErlang">
<label class="mt-2">Service level target (%)</label>
<input class="form-control form-control-sm mb-1" id="svTarget" type="number" value="80"/>
<label>ASA target (seconds)</label>
<input class="form-control form-control-sm mb-1" id="asaTarget" type="number" value="20"/>
<label>Occupancy target (%)</label>
<input class="form-control form-control-sm mb-1" id="occupancy" step="0.1" type="number" value="85"/>
<label>Shrinkage (%)</label>
<input class="form-control form-control-sm mb-1" id="shrinkage" step="0.1" type="number" value="30"/>
<label>Intraday deviation (%)</label>
<input class="form-control form-control-sm mb-2" id="intradayDev" step="0.1" type="number" value="10"/>
<div class="d-flex gap-2">
<button class="btn btn-outline-success btn-compact" id="saveErlangBtn">Save</button>
</div>
<div class="small-muted mt-2" id="erlangMsg"></div>
</div>
</div>
<div class="tab-pane fade" id="st-closed">
<div class="collapse show" id="secHolidays">
<input class="form-control form-control-sm mb-1 mt-2" id="holidayDate" type="date"/>
<button class="btn btn-sm btn-outline-secondary btn-compact mb-2" id="addHoliday">Add Holiday</button>
<ul class="list-group small mb-2" id="holList"></ul>
<div class="d-flex gap-2">
<button class="btn btn-outline-success btn-compact" id="saveHolidaysBtn">Save</button>
</div>
<div class="small-muted mt-2" id="holidayMsg"></div>
</div>
</div>
<div class="tab-pane fade" id="st-volume">
<div class="collapse show" id="secVol">
<div class="small-muted mt-1">Apply % increase/decrease to <strong>Forecast Calls</strong> for a method across a date range.</div>
<div class="row g-2 mt-2">
<div class="col-12">
<label class="small-muted mb-1">Forecast type</label>
<select class="form-select form-select-sm" id="volMethod">
<option value="ts">Time Series</option>
<option selected="" value="reg">Regression</option>
<option value="ai">AI</option>
<option value="openai">OpenAI</option>
</select>
</div>
<div class="col-6">
<label class="small-muted mb-1">Start</label>
<input class="form-control form-control-sm" id="volStart" type="date"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">End</label>
<input class="form-control form-control-sm" id="volEnd" type="date"/>
</div>
<div class="col-12">
<label class="small-muted mb-1">% change (e.g. 10 or -5)</label>
<input class="form-control form-control-sm" id="volPct" placeholder="10" step="0.1" type="number"/>
</div>
</div>
<div class="d-flex gap-2 mt-2">
<button class="btn btn-outline-primary btn-compact" id="addVolBtn">Add Volume Assumption</button>
<button class="btn btn-outline-success btn-compact" id="saveVolBtn">Save</button>
</div>
<div class="mt-2" id="volList"></div>
<div class="small-muted mt-2" id="volMsg"></div>
</div>
</div>
<div class="tab-pane fade" id="st-events">
<div class="collapse show" id="secEvents">
<div class="small-muted mt-1">
            Add a <strong>Past Event</strong> to measure historical impact (Calls &amp; AHT), then add a <strong>Future Event</strong> that references it.
            The forecast will automatically apply a scaled lift (or drop) to the future date and nearby dates.
          </div>
<div class="border rounded p-2 mt-2 soft-panel">
<div class="small-muted" style="font-weight:900;">Past Event (learn impact)</div>
<div class="row g-2 mt-1">
<div class="col-12">
<label class="small-muted mb-1">Event name</label>
<input class="form-control form-control-sm" id="pastEventName" placeholder="e.g., 2M Rewards Email"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Past event date</label>
<input class="form-control form-control-sm" id="pastEventDate" type="date"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Event magnitude</label>
<input class="form-control form-control-sm" id="pastEventMagnitude" placeholder="2000000" step="1" type="number"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Effect window before (days)</label>
<input class="form-control form-control-sm" id="pastWinBefore" step="1" type="number" value="0"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Effect window after (days)</label>
<input class="form-control form-control-sm" id="pastWinAfter" step="1" type="number" value="2"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Baseline lookback (days)</label>
<input class="form-control form-control-sm" id="pastLookback" step="1" type="number" value="56"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Exclude holidays (baseline)</label>
<select class="form-select form-select-sm" id="pastExcludeHolidays">
<option selected="" value="yes">Yes</option>
<option value="no">No</option>
</select>
</div>
</div>
<div class="d-flex gap-2 mt-2">
<button class="btn btn-outline-secondary btn-compact" id="addPastEventBtn">Add Past Event</button>
</div>
<div class="small-muted mt-2" id="pastEventMsg"></div>
</div>
<div class="border rounded p-2 mt-2 soft-panel">
<div class="small-muted" style="font-weight:900;">Future Event (apply impact)</div>
<div class="row g-2 mt-1">
<div class="col-12">
<label class="small-muted mb-1">Reference past event</label>
<select class="form-select form-select-sm" id="futureRefPast"></select>
</div>
<div class="col-12">
<label class="small-muted mb-1">Future event name</label>
<input class="form-control form-control-sm" id="futureEventName" placeholder="e.g., 600k Rewards Email"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Future event date</label>
<input class="form-control form-control-sm" id="futureEventDate" type="date"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Future magnitude</label>
<input class="form-control form-control-sm" id="futureEventMagnitude" placeholder="600000" step="1" type="number"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Apply before (days)</label>
<input class="form-control form-control-sm" id="futureSpreadBefore" step="1" type="number" value="0"/>
</div>
<div class="col-6">
<label class="small-muted mb-1">Apply after (days)</label>
<input class="form-control form-control-sm" id="futureSpreadAfter" step="1" type="number" value="2"/>
</div>
<div class="col-12">
<label class="small-muted mb-1">Decay</label>
<select class="form-select form-select-sm" id="futureDecay">
<option selected="" value="linear">Linear (strongest on event date)</option>
<option value="none">No decay (same impact for all days)</option>
</select>
</div>
</div>
<div class="d-flex gap-2 mt-2">
<button class="btn btn-outline-primary btn-compact" id="addFutureEventBtn">Add Future Event</button>
<button class="btn btn-outline-success btn-compact" id="saveEventsBtn">Save</button>
</div>
<div class="small-muted mt-2" id="futureEventMsg"></div>
</div>
<div class="mt-2">
<div class="small-muted" style="font-weight:900;">Past events</div>
<div class="mt-1" id="pastEventsList"></div>
</div>
<div class="mt-2">
<div class="small-muted" style="font-weight:900;">Future events</div>
<div class="mt-1" id="futureEventsList"></div>
</div>
<div class="event-note">
            Notes: Event adjustments apply to <strong>Calls and AHT</strong>. Volume % assumptions still apply (calls only) and stack with event adjustments.
            If a day is closed (no HOOP/intraday) or a holiday (blank), events will not override blanks.
          </div>
</div>
</div>

<div class="tab-pane fade" id="st-holidayintel">
  <div class="collapse show" id="secHolidayIntel">
    <div class="small-muted mt-1">
      Add a <strong>Past Holiday</strong>, click <strong>Analyze</strong> to learn the impact around it (example: day before / after),
      then add a <strong>Future Holiday</strong> that references it. The forecast will automatically apply the learned pattern to all forecast methods.
    </div>

    <div class="border rounded p-2 mt-2 soft-panel">
      <div class="small-muted" style="font-weight:900;">Past Holiday (learn impact)</div>
      <div class="row g-2 mt-1">
        <div class="col-12">
          <label class="small-muted mb-1">Holiday name</label>
          <input class="form-control form-control-sm" id="pastHolidayName" placeholder="e.g., Christmas"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Past holiday date</label>
          <input class="form-control form-control-sm" id="pastHolidayDate" type="date"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Baseline lookback (days)</label>
          <input class="form-control form-control-sm" id="pastHolidayLookback" type="number" step="1" value="84"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Effect window before (days)</label>
          <input class="form-control form-control-sm" id="pastHolidayWinBefore" type="number" step="1" value="3"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Effect window after (days)</label>
          <input class="form-control form-control-sm" id="pastHolidayWinAfter" type="number" step="1" value="3"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Exclude holidays (baseline)</label>
          <select class="form-select form-select-sm" id="pastHolidayExcludeHolidays">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Skip the holiday date itself</label>
          <select class="form-select form-select-sm" id="pastHolidaySkipDay0">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
      </div>

      <div class="d-flex gap-2 mt-2">
<button class="btn btn-outline-secondary btn-compact" id="addPastHolidayBtn">Add Past Holiday</button>
      </div>
      <div class="small-muted mt-2" id="pastHolidayMsg"></div>
      <div class="mt-2" id="pastHolidayPreview"></div>
    </div>

    <div class="border rounded p-2 mt-2 soft-panel">
      <div class="small-muted" style="font-weight:900;">Future Holiday (apply impact)</div>
      <div class="row g-2 mt-1">
        <div class="col-12">
          <label class="small-muted mb-1">Holiday name</label>
          <input class="form-control form-control-sm" id="futureHolidayName" placeholder="e.g., Christmas"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Future holiday date</label>
          <input class="form-control form-control-sm" id="futureHolidayDate" type="date"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Reference past holiday</label>
          <select class="form-select form-select-sm" id="futureHolidayRefPast"></select>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Apply before (days)</label>
          <input class="form-control form-control-sm" id="futureHolidaySpreadBefore" type="number" step="1" value="3"/>
        </div>
        <div class="col-6">
          <label class="small-muted mb-1">Apply after (days)</label>
          <input class="form-control form-control-sm" id="futureHolidaySpreadAfter" type="number" step="1" value="3"/>
        </div>
        <div class="col-12">
          <label class="small-muted mb-1">Decay</label>
          <select class="form-select form-select-sm" id="futureHolidayDecay">
            <option value="linear" selected>Linear (strongest closest to holiday)</option>
            <option value="none">No decay</option>
          </select>
        </div>
      </div>
      <div class="d-flex gap-2 mt-2">
        <button class="btn btn-outline-secondary btn-compact" id="addFutureHolidayBtn">Add Future Holiday</button>
      </div>
      <div class="small-muted mt-2" id="futureHolidayMsg"></div>
    </div>

    <div class="mt-2" id="holidayIntelList"></div>
  </div>
</div>

<div class="tab-pane fade" id="st-openai">
<div class="collapse show" id="secOpenAI">
<div class="small-muted mt-1">
            For security, browsers should call OpenAI via <strong>your backend/proxy</strong>. This tool posts to a configurable proxy URL that you host.
          </div>
<label class="mt-2">Proxy URL (your server endpoint)</label>
<input class="form-control form-control-sm mb-1" id="openaiProxyUrl" placeholder="https://your-domain.com/openai-forecast"/>
<label>Model (optional)</label>
<input class="form-control form-control-sm mb-1" id="openaiModel" placeholder="gpt-4.1-mini (example)"/>
<label>Temperature</label>
<input class="form-control form-control-sm mb-2" id="openaiTemp" step="0.1" type="number" value="0.2"/>
<div class="d-flex gap-2">
<button class="btn btn-outline-success btn-compact" id="saveOpenAISettingsBtn">Save</button>
</div>
<div class="small-muted mt-2" id="openaiMsg"></div>
</div>
</div>
</div>
</div>
</div>
<div class="col-lg-8">
<ul class="nav nav-tabs clean-tabs" id="resultsTabsClean" role="tablist">
  <li class="nav-item"><button class="nav-link active" data-bs-target="#rt-vis" data-bs-toggle="tab" type="button">Visualization</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-target="#rt-monthly" data-bs-toggle="tab" type="button">Monthly</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-target="#rt-daily" data-bs-toggle="tab" type="button">Daily</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-target="#rt-intra-forecast" data-bs-toggle="tab" type="button">Intraday</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-target="#rt-intra" data-bs-toggle="tab" type="button">Intra Pattern</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-target="#rt-api" data-bs-toggle="tab" type="button">API Data</button></li>
</ul>
<div class="tab-content tab-content-area">
<div class="tab-pane fade show active" id="rt-vis">
<div class="glass-card">
<canvas height="120" id="forecastChart"></canvas>
<div class="mt-2 small-muted" id="outputs"></div>
</div>
</div>
<div class="tab-pane fade" id="rt-daily">
<div class="glass-card">
<div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
<h5 class="mb-0" style="font-weight:900;letter-spacing:-0.01em;color:rgba(15,23,42,.92);">Daily</h5>
<div class="d-flex gap-2">
<button class="btn btn-outline-secondary btn-compact" id="exportActiveBtn" title="Exports the currently selected Daily tab (Time Series / Regression / AI / OpenAI).">Export CSV</button>
</div>
</div>
<ul class="nav nav-tabs clean-tabs mt-2" id="forecastTabs" role="tablist">
<li class="nav-item"><button class="nav-link active" data-bs-target="#tsTab" data-bs-toggle="tab" type="button">Time Series</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#regTab" data-bs-toggle="tab" type="button">Regression</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#aiTab" data-bs-toggle="tab" type="button">AI</button></li>
<li class="nav-item"><button class="nav-link" data-bs-target="#openaiTab" data-bs-toggle="tab" type="button">OpenAI</button></li>
</ul>
<div class="tab-content p-2">
<div class="tab-pane fade show active" id="tsTab"><div class="small-muted mb-2" id="tsModelInfo"></div><div id="tsTable"></div></div>
<div class="tab-pane fade" id="regTab"><div id="regTable"></div></div>
<div class="tab-pane fade" id="aiTab"><div id="aiTable"></div></div>
<div class="tab-pane fade" id="openaiTab"><div id="openaiTable"></div></div>
</div>
</div>
</div>

<div class="tab-pane fade" id="rt-monthly">
  <div class="glass-card">
    <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
      <h5 class="mb-0" style="font-weight:900;letter-spacing:-0.01em;color:rgba(15,23,42,92);">Monthly</h5>
      <div class="d-flex gap-2">
        <button class="btn btn-outline-secondary btn-compact" id="exportMonthlyActiveBtn" title="Exports the currently selected Monthly tab (Time Series / Regression / AI / OpenAI).">Export CSV</button>
      </div>
    </div>

    <ul class="nav nav-tabs clean-tabs mt-2" id="monthlyForecastTabs" role="tablist">
      <li class="nav-item"><button class="nav-link active" data-bs-target="#mTsTab" data-bs-toggle="tab" type="button">Time Series</button></li>
      <li class="nav-item"><button class="nav-link" data-bs-target="#mRegTab" data-bs-toggle="tab" type="button">Regression</button></li>
      <li class="nav-item"><button class="nav-link" data-bs-target="#mAiTab" data-bs-toggle="tab" type="button">AI</button></li>
      <li class="nav-item"><button class="nav-link" data-bs-target="#mOpenAiTab" data-bs-toggle="tab" type="button">OpenAI</button></li>
    </ul>

    <div class="tab-content p-2">
      <div class="tab-pane fade show active" id="mTsTab"><div id="mTsTable"></div></div>
      <div class="tab-pane fade" id="mRegTab"><div id="mRegTable"></div></div>
      <div class="tab-pane fade" id="mAiTab"><div id="mAiTable"></div></div>
      <div class="tab-pane fade" id="mOpenAiTab"><div id="mOpenAiTable"></div></div>
    </div>
  </div>
</div>

<div class="tab-pane fade" id="rt-intra">
<div class="glass-card">
<div class="d-flex justify-content-between align-items-center flex-wrap gap-2 mb-2">
<div class="fw-bold" style="color:rgba(15,23,42,.92);">Intra Pattern</div>
<span class="pill">30-min intervals</span>
</div>
<div class="collapse show" id="secIntraday">
<div class="small-muted">
            Enter <strong>% of daily calls</strong> per interval (0.5 = 0.5%). Fixed: <strong>5:00 AM–10:00 PM</strong>.
            Each day auto-normalizes within HOOP.
          </div>
<div class="d-flex justify-content-between align-items-center mt-2 flex-wrap gap-2">
<div class="small-muted" id="intradayTotals"></div>
<div class="d-flex align-items-center gap-2">
<button class="btn btn-outline-secondary btn-compact" id="fillEvenBtn">Fill Even</button>
<button class="btn btn-outline-secondary btn-compact" id="clearAllBtn">Clear</button>
<button class="btn btn-outline-secondary btn-compact" id="copyMonBtn">Copy Mon → All</button>
<button class="btn btn-outline-success btn-compact" id="saveIntradayBtn">Save</button>
</div>
</div>
<div class="table-intraday-wrap mt-2">
<table class="table table-sm table-bordered intraday-table mb-0" id="intradayTable"></table>
</div>
<div class="small-muted mt-2" id="intradayMsg"></div>
</div>
</div>
</div>

<div class="tab-pane fade" id="rt-api">
  <div class="glass-card">
    <div class="d-flex justify-content-between align-items-center flex-wrap gap-2 mb-2">
      <div class="fw-bold" style="color:rgba(15,23,42,.9)">API Data Preview</div>
      <div class="d-flex gap-2 align-items-center flex-wrap">
        <span class="pill" id="apiStatusPill">Not connected</span>
        <button class="btn btn-outline-secondary btn-compact" id="apiRefreshPreviewBtn" type="button">Refresh View</button>
      </div>
    </div>

    <div class="small-muted" id="apiDataMeta"></div>
    <div class="mt-2" id="apiDataTable"></div>
    <div class="small-muted mt-2" id="apiDataMsg"></div>
  </div>
</div>
<div class="tab-pane fade" id="rt-intra-forecast">
  <div class="glass-card">
    <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
      <h5 class="mb-0" style="font-weight:900;letter-spacing:-0.01em;color:rgba(15,23,42,.92);">Intraday</h5>
      <div class="d-flex align-items-center gap-2 flex-wrap">
        <span class="pill">30-min intervals</span>
        <div class="d-flex align-items-center gap-2">
          <label class="small-muted m-0" for="intraForecastDate" style="white-space:nowrap;">Select date</label>
          <input type="date" class="form-control form-control-sm" id="intraForecastDate" style="width: 170px;"/>
        </div>
      </div>
        <div class="d-flex gap-2">
          <button class="btn btn-outline-secondary btn-compact" id="exportIntraActiveBtn" title="Exports the currently selected Intraday tab (Time Series / Regression / AI / OpenAI) for the selected date.">Export CSV</button>
        </div>
    </div>

    <ul class="nav nav-tabs clean-tabs mt-2" id="intraForecastTabs" role="tablist">
      <li class="nav-item"><button class="nav-link active" data-bs-target="#intraTsTab" data-bs-toggle="tab" type="button">Time Series</button></li>
      <li class="nav-item"><button class="nav-link" data-bs-target="#intraRegTab" data-bs-toggle="tab" type="button">Regression</button></li>
      <li class="nav-item"><button class="nav-link" data-bs-target="#intraAiTab" data-bs-toggle="tab" type="button">AI</button></li>
      <li class="nav-item"><button class="nav-link" data-bs-target="#intraOpenAiTab" data-bs-toggle="tab" type="button">OpenAI</button></li>
    </ul>

    <div class="tab-content p-2">
      <div class="tab-pane fade show active" id="intraTsTab"><div id="intraTsTable"></div></div>
      <div class="tab-pane fade" id="intraRegTab"><div id="intraRegTable"></div></div>
      <div class="tab-pane fade" id="intraAiTab"><div id="intraAiTable"></div></div>
      <div class="tab-pane fade" id="intraOpenAiTab"><div id="intraOpenAiTable"></div></div>
    </div>

    <div class="small-muted mt-1" id="intraForecastMsg"></div>
  </div>
</div>

</div>
</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script>
/* ============================================================
   SAFETY GUARD (prevents one missing element from killing JS)
   ============================================================ */
function $(id){ return document.getElementById(id); }
function onClick(id, fn){
  const el = $(id);
  if(!el) return;
  el.addEventListener('click', fn);
}
function setText(id, msg){
  const el = $(id);
  if(el) el.innerText = msg || "";
}
window.addEventListener('error', (ev)=>{
  const box = $('jsErr');
  if(box){
    box.style.display = 'block';
    box.innerText = "JavaScript error: " + (ev?.message || "Unknown") + " (buttons may not work until fixed).";
  }
});

/* -------------------- STORAGE KEYS -------------------- */
const LS = {
  HOOP: "wf_forecast_hoops_v1",
  ERLANG: "wf_forecast_erlang_v1",
  HOLIDAYS: "wf_forecast_holidays_v1",
  INTRADAY: "wf_forecast_intraday_v1",
  VOLUME: "wf_forecast_volume_assumptions_v1",
  EVENTS: "wf_forecast_event_intel_v1",
  HOLIDAY_INTEL: "wf_forecast_holiday_intel_v1",
  OPENAI: "wf_forecast_openai_settings_v1",
  API_SETTINGS: "wf_forecast_api_settings_v1",
  API_CACHE: "wf_forecast_api_cache_v1"
};

/* -------------------- STATE -------------------- */
const state = {
  raw: null,
  holidays: [],
  hoops: [],
  volumeAssumptions: [],
  events: { past: [], future: [] },
  holidayIntel: { past: [], future: [] },
  baseForecasts: { ts: [], reg: [], ai: [], openai: [] },
  forecasts: { ts: [], reg: [], ai: [], openai: [] },
  intraday: {
    monday: [], tuesday: [], wednesday: [], thursday: [], friday: [], saturday: [], sunday: []
  },
  openai: { proxyUrl:"", model:"", temp:0.2 },

  // API data source (optional)
  api: { sourceType:"rest", proxyUrl:"", authType:"none", authValue:"", headersJson:"", lastSync:null },
  apiCache: { daily: null, intraday: null }
};

/* Fixed intraday window: 5:00 AM - 10:00 PM (30-min) */
const START_MIN = 5 * 60;
const END_MIN   = 22 * 60;
const INTERVAL_MIN = 30;
const INTERVALS = Math.round((END_MIN - START_MIN) / INTERVAL_MIN);
const INTERVAL_SECONDS = INTERVAL_MIN * 60;

const DAY_KEYS = ["monday","tuesday","wednesday","thursday","friday","saturday","sunday"];
const DAY_LABELS = ["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"];

/* -------------------- LOADING OVERLAY HELPERS -------------------- */
const loadingOverlay = document.getElementById('ai-loader-overlay');
const loadingMsgEl = document.getElementById('loader-status-text');

function _safeText(s){
  return String(s ?? '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}
function showLoading(msg){
  const m = (msg || "Training AI Model.").trim();
  if(loadingMsgEl){
    loadingMsgEl.innerHTML = `${_safeText(m)}<span class="dots"><span>.</span><span>.</span><span>.</span></span>`;
  }
  if(loadingOverlay){
    loadingOverlay.style.display = 'flex';
    loadingOverlay.style.opacity = '1';
  }
}
function updateLoading(msg){
  const m = (msg || "Training AI Model.").trim();
  if(loadingMsgEl){
    loadingMsgEl.innerHTML = `${_safeText(m)}<span class="dots"><span>.</span><span>.</span><span>.</span></span>`;
  }
}
function hideLoading(){
  if(loadingOverlay) loadingOverlay.style.display = 'none';
}
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
/* -------------------- UI HELPERS -------------------- */
function showPill(id, ms=1200){
  const el = $(id);
  if(!el) return;
  el.classList.remove('d-none');
  setTimeout(()=> el.classList.add('d-none'), ms);
}
function setMsg(id, msg){ setText(id, msg); }
function escapeHtml(str){
  return String(str ?? '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}
function fmtInt(n){
  if(n===null || n===undefined || !isFinite(n)) return "";
  return Math.round(n).toLocaleString();
}
function toISODate(d){
  const dt = (d instanceof Date) ? d : new Date(d);
  if(isNaN(dt)) return "";
  return dt.toISOString().slice(0,10);
}
function addDays(date, days){
  const d = new Date(date);
  d.setDate(d.getDate()+days);
  return d;
}
function daterange(startISO, endISO){
  const out=[];
  const s = new Date(startISO+"T00:00:00");
  const e = new Date(endISO+"T00:00:00");
  if(isNaN(s)||isNaN(e)||s>e) return out;
  for(let d=new Date(s); d<=e; d=addDays(d,1)){
    out.push(toISODate(d));
  }
  return out;
}
function dowIdxFromISO(iso){
  const d=new Date(iso+"T00:00:00");
  const js=d.getDay();
  const map = [6,0,1,2,3,4,5];
  return map[js];
}
function dayKeyFromDowIdx(i){ return DAY_KEYS[i]; }
function clamp(n, lo, hi){
  n = Number(n);
  if(!isFinite(n)) return lo;
  return Math.max(lo, Math.min(hi, n));
}
function uid(prefix="id"){
  return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
}

/* -------------------- DAY LABEL HELPERS -------------------- */
const DOW_SHORT = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
function dayShortFromISO(iso){
  const i = dowIdxFromISO(iso);
  return DOW_SHORT[i] || "";
}
function fmtDateMDY(iso){
  const s = String(iso||"").trim();
  if(!/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  const [y,m,d] = s.split("-");
  return `${m}-${d}-${y}`;
}
function monthKeyFromISO(iso){
  // Robust: accepts YYYY-MM-DD, MM-DD-YYYY, MM/DD/YYYY, or any Date-parsable string.
  if(iso===null || iso===undefined) return "";
  if(iso instanceof Date && !isNaN(iso)){
    const y = iso.getFullYear();
    const m = String(iso.getMonth()+1).padStart(2,'0');
    return `${y}-${m}`;
  }
  const s = String(iso).trim();
  if(!s) return "";
  // YYYY-MM-DD (or ISO date prefix)
  if(/^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0,7);
  // MM-DD-YYYY
  let mdy = s.match(/^(\d{2})-(\d{2})-(\d{4})$/);
  if(mdy) return `${mdy[3]}-${mdy[1]}`;
  // MM/DD/YYYY
  mdy = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if(mdy){
    const mm = String(mdy[1]).padStart(2,'0');
    return `${mdy[3]}-${mm}`;
  }
  const d = new Date(s);
  if(!isNaN(d)){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    return `${y}-${m}`;
  }
  return "";
}


function monthLabelFromKey(ym){
  if(!/^\d{4}-\d{2}$/.test(ym)) return ym;
  const [y,m] = ym.split("-");
  const dt = new Date(`${y}-${m}-01T00:00:00`);
  return dt.toLocaleString(undefined, {month:"long", year:"numeric"});
}

/* -------------------- TIME FORMAT (AM/PM) HELPERS -------------------- */
function minutesToTime12(mins){
  const h24 = Math.floor(mins/60);
  const m = mins%60;
  const ampm = h24 >= 12 ? "PM" : "AM";
  let h12 = h24 % 12;
  if(h12 === 0) h12 = 12;
  return `${h12}:${String(m).padStart(2,'0')} ${ampm}`;
}
function hhmmToTime12(hhmm){
  const m = String(hhmm||"").trim().match(/^(\d{1,2}):(\d{2})$/);
  if(!m) return String(hhmm||"");
  const hh = Number(m[1]), mm = Number(m[2]);
  if(!Number.isFinite(hh) || !Number.isFinite(mm)) return String(hhmm||"");
  return minutesToTime12(hh*60 + mm);
}
function buildTimeOptions(stepMin=30){
  const opts = [];
  for(let mins=0; mins<24*60; mins+=stepMin){
    const hh = String(Math.floor(mins/60)).padStart(2,'0');
    const mm = String(mins%60).padStart(2,'0');
    opts.push({ value: `${hh}:${mm}`, label: minutesToTime12(mins) });
  }
  return opts;
}

/* -------------------- CSV EXPORT HELPERS -------------------- */
function csvEscape(val){
  if(val===null || val===undefined) return "";
  const s = String(val);
  if(/[",\n\r]/.test(s)) return `"${s.replaceAll('"','""')}"`;
  return s;
}
function rowsToCSV(rows, headers){
  const lines = [];
  lines.push(headers.map(csvEscape).join(","));
  for(const r of rows){
    const line = headers.map(h=>{
      const v = (r && Object.prototype.hasOwnProperty.call(r, h)) ? r[h] : "";
      return csvEscape(v);
    }).join(",");
    lines.push(line);
  }
  return lines.join("\r\n");
}
function downloadCSV(filename, csvText){
  const blob = new Blob([csvText], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}
function exportForecastCSV(kind){
  const rows = (state.forecasts && state.forecasts[kind]) ? state.forecasts[kind] : [];
  if(!rows.length){
    alert("No forecast rows to export yet. Please generate a forecast first.");
    return;
  }
  const exportRows = rows.map(r=>({
    "Date": r.date ?? "",
    "Day": dayShortFromISO(r.date ?? ""),
    "Forecast Calls": (r.calls===null || r.calls===undefined) ? "" : Math.round(r.calls),
    "AHT (sec)": (r.aht===null || r.aht===undefined) ? "" : Math.round(r.aht),
    "FTE Need (No Shrinkage)": (r.servers===null || r.servers===undefined) ? "" : Math.round(r.servers),
    "FTE Need (Shrinkage)": (r.staffing===null || r.staffing===undefined) ? "" : Math.round(r.staffing)
  }));
  const headers = ["Date","Day","Forecast Calls","AHT (sec)","FTE Need (No Shrinkage)","FTE Need (Shrinkage)"];
  const csv = rowsToCSV(exportRows, headers);

  const start = $('startDate')?.value || "";
  const end = $('endDate')?.value || "";
  const tag = (kind==="ts") ? "TimeSeries" : (kind==="reg" ? "Regression" : (kind==="ai" ? "AI" : "OpenAI"));
  const fname = `Forecast_${tag}_${start || "start"}_${end || "end"}.csv`;
  downloadCSV(fname, csv);
}

function getActiveIntradayForecastKind(){
  const activeBtn = document.querySelector('#intraForecastTabs .nav-link.active');
  const target = activeBtn?.getAttribute('data-bs-target') || '#intraTsTab';
  if(target === '#intraRegTab') return 'reg';
  if(target === '#intraAiTab') return 'ai';
  if(target === '#intraOpenAiTab') return 'openai';
  return 'ts';
}

function exportIntradayForecastCSV(){
  const kind = getActiveIntradayForecastKind();
  const dateISO = $('intraForecastDate')?.value || "";
  if(!dateISO){
    alert("Please select a date first.");
    return;
  }
  const rows = buildIntradayForecastRowsForDate(kind, dateISO);
  if(!rows || !rows.length){
    alert("No intraday forecast rows to export for the selected date. Please generate a forecast and ensure the date is within range and open.");
    return;
  }
  const exportRows = rows.map(r=>({
    "Date": fmtDateMDY(dateISO),
    "Day": dayShortFromISO(dateISO),
    "Interval": r.interval ?? "",
    "Forecast Calls": (r.calls===null || r.calls===undefined) ? "" : Math.round(r.calls),
    "AHT (sec)": (r.aht===null || r.aht===undefined) ? "" : Math.round(r.aht),
    "FTE Need (No Shrinkage)": (r.servers===null || r.servers===undefined) ? "" : Math.round(r.servers),
    "FTE Need (Shrinkage)": (r.staffing===null || r.staffing===undefined) ? "" : Math.round(r.staffing)
  }));
  const headers = ["Date","Day","Interval","Forecast Calls","AHT (sec)","FTE Need (No Shrinkage)","FTE Need (Shrinkage)"];
  const csv = rowsToCSV(exportRows, headers);
  const tag = (kind==="ts") ? "TimeSeries" : (kind==="reg" ? "Regression" : (kind==="ai" ? "AI" : "OpenAI"));
  const fname = `Intraday_Forecast_${tag}_${fmtDateMDY(dateISO)}.csv`;
  downloadCSV(fname, csv);
}

function exportMonthlyForecastCSV(methodKey){
  const dailyRows = (state.forecasts && state.forecasts[methodKey]) ? state.forecasts[methodKey] : [];
  const groups = buildMonthlySummaries(dailyRows);
  const monthItems = groups.map(g=>{
    const sum = summarizeMonthForTable(g.rows);
    return {
      Month: g.label,
      Calls: Math.round(sum.totalCalls||0),
      "AHT (sec)": (sum.avgAht===null ? "" : Math.round(sum.avgAht)),
      "FTE Need (No Shr.)": (sum.avgFteNoShr===null ? "" : Math.round(sum.avgFteNoShr)),
      "FTE Need (Shr.)": (sum.avgFteShr===null ? "" : Math.round(sum.avgFteShr)),
      "Days Included": sum.daysIncluded||0
    };
  });

  const yearItems = buildYearSummariesFromMonthly(monthItems.map(mi=>{
    // Adapt to buildYearSummariesFromMonthly signature
    // monthItems here doesn't have monthKey, keep a hidden copy:
    return mi;
  }));

  // For simplicity, export month table only (what user asked for)
  const header = ["Month","Calls","AHT (sec)","FTE Need (No Shr.)","FTE Need (Shr.)","Days Included"];
  const lines = [header.join(",")];
  monthItems.forEach(r=>{
    const row = header.map(h=> csvEscape(r[h] ?? r[h.replace(/ \(.*\)/,'')] ?? r[h]));
    lines.push(row.join(","));
  });
  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8;"});
  const name = `monthly_forecast_${methodKey}_${toISODate(new Date())}.csv`;
  downloadBlob(blob, name);
}

/* -------------------- HOLIDAY NORMALIZATION + BLANKING -------------------- */
function normalizeISODateString(s){
  const str = String(s || "").trim();
  if(/^\d{4}-\d{2}-\d{2}$/.test(str)) return str;
  const d = new Date(str);
  if(!isNaN(d)) return d.toISOString().slice(0,10);
  return "";
}
function getHolidaySet(){
  const set = new Set();
  (state.holidays || []).forEach(h => {
    const iso = normalizeISODateString(h);
    if(iso) set.add(iso);
  });
  return set;
}
function applyHolidayBlanks(rows){
  const hol = getHolidaySet();
  return rows.map(r=>{
    const iso = normalizeISODateString(r.date);
    if(iso && hol.has(iso)){
      return {...r, calls: null, aht: null, servers: null, staffing: null};
    }
    return r;
  });
}

/* -------------------- VOLUME ASSUMPTIONS (CALLS ONLY) -------------------- */
function methodLabel(method){
  if(method==="ts") return "Time Series";
  if(method==="reg") return "Regression";
  if(method==="ai") return "AI";
  if(method==="openai") return "OpenAI";
  return method;
}
function renderVolumeAssumptions(){
  const container = $('volList');
  if(!container) return;
  container.innerHTML = "";

  if(!state.volumeAssumptions.length){
    container.innerHTML = `<div class="small-muted">No volume assumptions yet.</div>`;
    return;
  }

  state.volumeAssumptions.forEach((a, idx)=>{
    const pct = Number(a.pct)||0;
    const sign = pct >= 0 ? "+" : "";
    const div = document.createElement('div');
    div.className = "border rounded p-2 mb-2 soft-panel";
    div.innerHTML = `
      <div>
        <strong>${escapeHtml(methodLabel(a.method))}</strong> •
        <strong>${escapeHtml(a.start)}</strong> → <strong>${escapeHtml(a.end)}</strong> •
        <strong>${escapeHtml(sign + pct)}</strong>%
      </div>
      <button class="btn btn-sm btn-outline-danger btn-compact mt-1">Remove</button>
    `;
    container.appendChild(div);

    div.querySelector('button').onclick = ()=>{
      const removed = state.volumeAssumptions[idx];
      state.volumeAssumptions.splice(idx,1);
      renderVolumeAssumptions();
      setMsg('volMsg', 'Removed (table updated).');
      if(removed?.method) recomputeAndRenderMethod(removed.method);
    };
  });
}
function saveVolumeAssumptions(){
  localStorage.setItem(LS.VOLUME, JSON.stringify(state.volumeAssumptions));
  showPill('volStatus');
  setMsg('volMsg', 'Saved to this browser.');
}
function loadVolumeAssumptions(){
  const raw = localStorage.getItem(LS.VOLUME);
  if(!raw) return false;
  try{
    const arr = JSON.parse(raw);
    state.volumeAssumptions = Array.isArray(arr) ? arr : [];
    renderVolumeAssumptions();
    setMsg('volMsg', 'Loaded saved volume assumptions.');
    return true;
  }catch{
    return false;
  }
}

function applyVolumeAssumptionsToCalls(rows, methodKey){
  if(!rows || !rows.length) return rows;
  const list = (state.volumeAssumptions || []).filter(a => a && a.method === methodKey);
  if(!list.length) return rows;

  return rows.map(r=>{
    if(!r || !r.date) return r;
    if(r.calls===null || r.calls===undefined || !isFinite(Number(r.calls))) return r;

    const iso = normalizeISODateString(r.date);
    if(!iso) return r;

    let calls = Number(r.calls);
    for(const a of list){
      const s = normalizeISODateString(a.start);
      const e = normalizeISODateString(a.end);
      if(!s || !e) continue;
      if(iso >= s && iso <= e){
        const pct = Number(a.pct)||0;
        calls = calls * (1 + (pct/100));
      }
    }
    return {...r, calls};
  });
}

/* -------------------- OPENAI SETTINGS -------------------- */
function saveOpenAISettings(){
  state.openai.proxyUrl = String($('openaiProxyUrl')?.value || "").trim();
  state.openai.model = String($('openaiModel')?.value || "").trim();
  state.openai.temp = clamp(Number($('openaiTemp')?.value || 0.2), 0, 2);
  localStorage.setItem(LS.OPENAI, JSON.stringify(state.openai));
  showPill('openaiStatus');
  setMsg('openaiMsg', 'Saved to this browser.');
}
function loadOpenAISettings(){
  const raw = localStorage.getItem(LS.OPENAI);
  if(!raw) return false;
  try{
    const obj = JSON.parse(raw);
    if(obj && typeof obj === "object"){
      state.openai.proxyUrl = String(obj.proxyUrl || "");
      state.openai.model = String(obj.model || "");
      state.openai.temp = isFinite(Number(obj.temp)) ? Number(obj.temp) : 0.2;
      if($('openaiProxyUrl')) $('openaiProxyUrl').value = state.openai.proxyUrl;
      if($('openaiModel')) $('openaiModel').value = state.openai.model;
      if($('openaiTemp')) $('openaiTemp').value = state.openai.temp;
      setMsg('openaiMsg', 'Loaded saved settings.');
      return true;
    }
  }catch{}
  return false;
}

/* -------------------- EVENT INTELLIGENCE (AI) -------------------- */
/* (Same logic as your original — unchanged besides safe element access) */
function getHistByISO(){
  const map = new Map();
  const hist = state.raw?.daily || [];
  hist.forEach(r=>{
    const iso = toISODate(r.date);
    if(iso) map.set(iso, {calls: Number(r.calls)||0, aht: Number(r.aht)||0});
  });
  return map;
}
function isHolidayISO(iso){
  const set = getHolidaySet();
  return set.has(iso);
}
function baselineForISO({targetISO, metric, lookbackDays=56, excludeHolidays=true}){
  const histMap = getHistByISO();
  const targetDow = dowIdxFromISO(targetISO);

  const tDate = new Date(targetISO+"T00:00:00");
  const start = addDays(tDate, -Math.max(7, lookbackDays));
  const end = addDays(tDate, -1);

  let sum=0, cnt=0;
  for(let d=new Date(start); d<=end; d=addDays(d,1)){
    const iso = toISODate(d);
    if(!iso) continue;
    if(dowIdxFromISO(iso) !== targetDow) continue;
    if(excludeHolidays && isHolidayISO(iso)) continue;
    const v = histMap.get(iso);
    if(!v) continue;
    const val = metric==="calls" ? (Number(v.calls)||0) : (Number(v.aht)||0);
    if(val > 0){
      sum += val;
      cnt += 1;
    }
  }
  return cnt ? (sum/cnt) : null;
}
function computePastEventImpact({
  name,
  dateISO,
  magnitude,
  winBefore=0,
  winAfter=2,
  lookbackDays=56,
  excludeHolidays=true
}){
  if(!state.raw?.daily?.length) return { ok:false, msg:"Upload historical data first." };
  const iso = normalizeISODateString(dateISO);
  if(!iso) return { ok:false, msg:"Invalid past event date." };

  const histMap = getHistByISO();
  const windowDates = daterange(toISODate(addDays(iso+"T00:00:00", -winBefore)), toISODate(addDays(iso+"T00:00:00", winAfter)));

  const holSet = getHolidaySet();
  const usable = [];
  for(const dISO of windowDates){
    if(excludeHolidays && holSet.has(dISO)) continue;
    const row = histMap.get(dISO);
    if(!row) continue;
    usable.push({iso:dISO, calls:Number(row.calls)||0, aht:Number(row.aht)||0});
  }

  if(!usable.length){
    return { ok:false, msg:"No historical rows found for that date/window (or excluded by holidays)." };
  }

  const avgCalls = usable.reduce((a,r)=>a+r.calls,0)/usable.length;
  const avgAht = usable.reduce((a,r)=>a+r.aht,0)/usable.length;

  let baseCallsSum=0, baseCallsCnt=0;
  let baseAhtSum=0, baseAhtCnt=0;

  usable.forEach(r=>{
    const bC = baselineForISO({targetISO:r.iso, metric:"calls", lookbackDays, excludeHolidays});
    const bA = baselineForISO({targetISO:r.iso, metric:"aht", lookbackDays, excludeHolidays});
    if(bC!==null && isFinite(bC) && bC>0){ baseCallsSum += bC; baseCallsCnt++; }
    if(bA!==null && isFinite(bA) && bA>0){ baseAhtSum += bA; baseAhtCnt++; }
  });

  const baseCalls = baseCallsCnt ? (baseCallsSum/baseCallsCnt) : null;
  const baseAht = baseAhtCnt ? (baseAhtSum/baseAhtCnt) : null;

  if(!baseCalls || !baseAht){
    return { ok:false, msg:"Could not compute baseline (not enough same-day history in lookback window)." };
  }

  const callsPct = ((avgCalls - baseCalls) / baseCalls) * 100;
  const ahtPct = ((avgAht - baseAht) / baseAht) * 100;

  const conf = Math.round(clamp(((baseCallsCnt + baseAhtCnt)/2) / Math.max(4, Math.floor(lookbackDays/7)), 0, 1) * 100);

  return {
    ok:true,
    impact:{
      id: uid("past"),
      name: String(name||"").trim() || "Past Event",
      date: iso,
      magnitude: isFinite(Number(magnitude)) ? Number(magnitude) : null,
      winBefore: clamp(winBefore, 0, 30),
      winAfter: clamp(winAfter, 0, 30),
      lookbackDays: clamp(lookbackDays, 14, 365),
      excludeHolidays: !!excludeHolidays,
      baseCalls: baseCalls,
      baseAht: baseAht,
      avgCalls: avgCalls,
      avgAht: avgAht,
      impactCallsPct: clamp(callsPct, -99.9, 500),
      impactAhtPct: clamp(ahtPct, -99.9, 500),
      confidence: conf
    }
  };
}

function renderEventsUI(){
  renderPastEvents();
  renderFutureEvents();
  rebuildPastEventDropdown();
}
function rebuildPastEventDropdown(){
  const sel = $('futureRefPast');
  if(!sel) return;
  sel.innerHTML = "";
  const past = state.events.past || [];
  if(!past.length){
    const opt = document.createElement('option');
    opt.value = "";
    opt.textContent = "Add a past event first…";
    sel.appendChild(opt);
    return;
  }
  past.slice().sort((a,b)=>(a.date||"").localeCompare(b.date||"")).forEach(p=>{
    const opt = document.createElement('option');
    opt.value = p.id;
    const mag = (p.magnitude!==null && p.magnitude!==undefined) ? ` • ${fmtInt(p.magnitude)}` : "";
    opt.textContent = `${p.name} (${p.date}${mag})`;
    sel.appendChild(opt);
  });
}
function renderPastEvents(){
  const container = $('pastEventsList');
  if(!container) return;
  container.innerHTML = "";
  const past = state.events.past || [];
  if(!past.length){
    container.innerHTML = `<div class="small-muted">No past events yet.</div>`;
    return;
  }
  past.forEach((p, idx)=>{
    const div = document.createElement('div');
    div.className = "border rounded p-2 mb-2 soft-panel";
    const callsBadge = `${(p.impactCallsPct>=0?"+":"")}${Math.round(p.impactCallsPct*10)/10}% Calls`;
    const ahtBadge = `${(p.impactAhtPct>=0?"+":"")}${Math.round(p.impactAhtPct*10)/10}% AHT`;
    const conf = `${fmtInt(p.confidence)}% conf`;
    div.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;">
        <div>
          <div><strong>${escapeHtml(p.name)}</strong> • <span class="event-badge">${escapeHtml(p.date)}</span></div>
          <div class="small-muted mt-1">
            Learned impact:
            <span class="event-badge">${escapeHtml(callsBadge)}</span>
            <span class="event-badge">${escapeHtml(ahtBadge)}</span>
            <span class="event-badge">${escapeHtml(conf)}</span>
          </div>
          <div class="small-muted mt-1">
            Window: ${escapeHtml(String(p.winBefore))}d before / ${escapeHtml(String(p.winAfter))}d after •
            Lookback: ${escapeHtml(String(p.lookbackDays))}d •
            Magnitude: ${p.magnitude==null ? "—" : escapeHtml(fmtInt(p.magnitude))}
          </div>
        </div>
        <div style="display:flex;gap:6px;align-items:start;">
          <button class="btn btn-sm btn-outline-danger btn-compact">Remove</button>
        </div>
      </div>
    `;
    container.appendChild(div);
    div.querySelector('button').onclick = ()=>{
      const removedId = p.id;
      state.events.past.splice(idx,1);
      state.events.future = (state.events.future||[]).filter(f => f.refPastId !== removedId);
      renderEventsUI();
  renderHolidayIntelUI();
      setMsg('pastEventMsg', 'Removed past event (and linked future events).');
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
}
function renderFutureEvents(){
  const container = $('futureEventsList');
  if(!container) return;
  container.innerHTML = "";
  const fut = state.events.future || [];
  if(!fut.length){
    container.innerHTML = `<div class="small-muted">No future events yet.</div>`;
    return;
  }
  const pastById = new Map((state.events.past||[]).map(p=>[p.id,p]));
  fut.slice().sort((a,b)=>(a.date||"").localeCompare(b.date||"")).forEach((f, idx)=>{
    const p = pastById.get(f.refPastId);
    const ratio = (p?.magnitude && f.magnitude) ? (Number(f.magnitude)/Number(p.magnitude)) : null;
    const ratioTxt = ratio===null ? "—" : `${Math.round(ratio*100)/100}x`;
    const div = document.createElement('div');
    div.className = "border rounded p-2 mb-2 soft-panel";
    div.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;">
        <div>
          <div><strong>${escapeHtml(f.name || "Future Event")}</strong> • <span class="event-badge">${escapeHtml(f.date)}</span></div>
          <div class="small-muted mt-1">
            Reference: <span class="event-badge">${escapeHtml(p ? p.name : "Missing past event")}</span>
            • Magnitude ratio: <span class="event-badge">${escapeHtml(ratioTxt)}</span>
            • Apply: <span class="event-badge">${escapeHtml(String(f.spreadBefore))}d before</span>
            <span class="event-badge">${escapeHtml(String(f.spreadAfter))}d after</span>
            <span class="event-badge">${escapeHtml(f.decay)}</span>
          </div>
          <div class="small-muted mt-1">Future magnitude: ${f.magnitude==null ? "—" : escapeHtml(fmtInt(f.magnitude))}</div>
        </div>
        <div style="display:flex;gap:6px;align-items:start;">
          <button class="btn btn-sm btn-outline-danger btn-compact">Remove</button>
        </div>
      </div>
    `;
    container.appendChild(div);
    div.querySelector('button').onclick = ()=>{
      state.events.future.splice(idx,1);
      renderEventsUI();
      setMsg('futureEventMsg', 'Removed future event.');
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
}
function saveEvents(){
  localStorage.setItem(LS.EVENTS, JSON.stringify(state.events));
  showPill('eventStatus');
  setMsg('futureEventMsg', 'Saved to this browser.');
  ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
}
function loadEvents(){
  const raw = localStorage.getItem(LS.EVENTS);
  if(!raw) return false;
  try{
    const obj = JSON.parse(raw);
    if(obj && typeof obj === "object"){
      state.events.past = Array.isArray(obj.past) ? obj.past : [];
      state.events.future = Array.isArray(obj.future) ? obj.future : [];
      renderEventsUI();
      setMsg('futureEventMsg', 'Loaded saved events.');
      return true;
    }
  }catch{}
  return false;
}
function analyzePastEventPreview(){
  const name = $('pastEventName')?.value;
  const dateISO = $('pastEventDate')?.value;
  const magnitude = $('pastEventMagnitude')?.value;
  const winBefore = Number($('pastWinBefore')?.value)||0;
  const winAfter = Number($('pastWinAfter')?.value)||0;
  const lookbackDays = Number($('pastLookback')?.value)||56;
  const excludeHolidays = (($('pastExcludeHolidays')?.value || "yes")==="yes");

  const res = computePastEventImpact({name, dateISO, magnitude, winBefore, winAfter, lookbackDays, excludeHolidays});
  if(!res.ok){
    setMsg('pastEventMsg', res.msg);
    return null;
  }
  const p = res.impact;
  const callsBadge = `${(p.impactCallsPct>=0?"+":"")}${Math.round(p.impactCallsPct*10)/10}% Calls`;
  const ahtBadge = `${(p.impactAhtPct>=0?"+":"")}${Math.round(p.impactAhtPct*10)/10}% AHT`;
  setMsg('pastEventMsg',
    `Analysis: ${callsBadge}, ${ahtBadge} (confidence ${p.confidence}%). Baseline used lookback ${p.lookbackDays} days.`
  );
  return p;
}

/* -------------------- EVENT APPLY HELPERS -------------------- */
function decayWeight(dist, spreadBefore, spreadAfter, mode){
  const maxSpread = Math.max(spreadBefore, spreadAfter);
  if(mode==="none") return 1;
  const denom = (maxSpread + 1);
  return clamp(1 - (dist/denom), 0, 1);
}
function applyEventAdjustments(rows){
  if(!rows || !rows.length) return rows;
  const fut = state.events.future || [];
  const past = state.events.past || [];
  if(!fut.length || !past.length) return rows;

  const pastById = new Map(past.map(p=>[p.id,p]));
  const holSet = getHolidaySet();

  const idxByDate = new Map();
  rows.forEach((r, i)=>{ if(r?.date) idxByDate.set(normalizeISODateString(r.date), i); });

  for(const f of fut){
    const p = pastById.get(f.refPastId);
    if(!p) continue;

    const eventISO = normalizeISODateString(f.date);
    if(!eventISO) continue;

    let ratio = 1;
    if(isFinite(Number(p.magnitude)) && Number(p.magnitude)>0 && isFinite(Number(f.magnitude)) && Number(f.magnitude)>0){
      ratio = Number(f.magnitude) / Number(p.magnitude);
      ratio = clamp(ratio, 0, 50);
    }

    const callsPct = clamp((Number(p.impactCallsPct)||0) * ratio, -99.9, 500);
    const ahtPct = clamp((Number(p.impactAhtPct)||0) * ratio, -99.9, 500);

    const before = clamp(Number(f.spreadBefore)||0, 0, 30);
    const after = clamp(Number(f.spreadAfter)||0, 0, 30);
    const window = daterange(toISODate(addDays(eventISO+"T00:00:00", -before)), toISODate(addDays(eventISO+"T00:00:00", after)));

    window.forEach(dISO=>{
      const i = idxByDate.get(dISO);
      if(i===undefined) return;

      const r = rows[i];
      if(!r || r.calls===null || r.calls===undefined || r.aht===null || r.aht===undefined) return;
      if(holSet.has(dISO)) return;

      const dist = Math.abs((new Date(dISO+"T00:00:00") - new Date(eventISO+"T00:00:00")) / (24*3600*1000));
      const w = decayWeight(dist, before, after, f.decay);

      const callsMult = 1 + (callsPct/100)*w;
      const ahtMult   = 1 + (ahtPct/100)*w;

      let newCalls = Number(r.calls);
      let newAht = Number(r.aht);

      if(isFinite(newCalls)){
        newCalls = newCalls * callsMult;
        newCalls = Math.max(0, newCalls);
      }
      if(isFinite(newAht)){
        newAht = newAht * ahtMult;
        newAht = clamp(newAht, 60, 7200);
      }

      rows[i] = {...r, calls: newCalls, aht: newAht};
    });
  }
  return rows;
}


/* -------------------- HOLIDAY INTELLIGENCE (learn + apply) -------------------- */
function safeNum(n, fallback=null){
  n = Number(n);
  return isFinite(n) ? n : fallback;
}
function mean(arr){
  const a=(arr||[]).filter(x=>isFinite(x));
  if(!a.length) return null;
  return a.reduce((s,v)=>s+v,0)/a.length;
}
function getRawByISO(){
  const m = new Map();
  (state.raw||[]).forEach(r=>{
    const iso = normalizeISODateString(r.date);
    if(!iso) return;
    const calls = safeNum(r.calls, null);
    const aht = safeNum(r.aht_seconds ?? r.aht, null);
    m.set(iso, { calls, aht });
  });
  return m;
}
function computeHolidayTemplate({name, dateISO, winBefore, winAfter, lookbackDays, excludeHolidays=true, skipDay0=true}){
  const rawMap = getRawByISO();
  const holSet = getHolidaySet();
  const effects = [];
  const wB = Math.max(0, Math.round(Number(winBefore)||0));
  const wA = Math.max(0, Math.round(Number(winAfter)||0));
  const lb = Math.max(14, Math.round(Number(lookbackDays)||56));

  const endISO = normalizeISODateString(addDays(dateISO, -1));
  const startISO = normalizeISODateString(addDays(dateISO, -lb));
  const lbDates = daterange(startISO, endISO);

  const excludeSet = new Set();
  for(let o=-wB; o<=wA; o++) excludeSet.add(normalizeISODateString(addDays(dateISO, o)));

  const poolsByDow = Array.from({length:7},()=>({calls:[], aht:[]}));
  lbDates.forEach(iso=>{
    if(excludeSet.has(iso)) return;
    if(excludeHolidays && holSet.has(iso)) return;
    const d = rawMap.get(iso);
    if(!d) return;
    const dow = dowIdxFromISO(iso);
    if(isFinite(d.calls)) poolsByDow[dow].calls.push(d.calls);
    if(isFinite(d.aht)) poolsByDow[dow].aht.push(d.aht);
  });

  for(let o=-wB; o<=wA; o++){
    if(skipDay0 && o===0) continue;
    const iso = normalizeISODateString(addDays(dateISO, o));
    const d = rawMap.get(iso);
    const dow = dowIdxFromISO(iso);
    const baseCalls = mean(poolsByDow[dow].calls);
    const baseAht = mean(poolsByDow[dow].aht);

    let callsMult = 1, ahtMult = 1;
    if(d && isFinite(d.calls) && isFinite(baseCalls) && baseCalls>0) callsMult = Math.max(0, d.calls / baseCalls);
    if(d && isFinite(d.aht) && isFinite(baseAht) && baseAht>0) ahtMult = clamp(d.aht / baseAht, 0.25, 4.0);

    effects.push({ offset:o, callsMult, ahtMult, dateISO: iso });
  }

  return {
    id: uid("hol"),
    name: String(name||"Holiday").trim() || "Holiday",
    dateISO,
    winBefore: wB,
    winAfter: wA,
    lookbackDays: lb,
    excludeHolidays: !!excludeHolidays,
    skipDay0: !!skipDay0,
    effects
  };
}
function analyzePastHolidayPreview(){
  const name = $('pastHolidayName')?.value;
  const d = $('pastHolidayDate')?.value;
  const dateISO = normalizeISODateString(d);
  if(!dateISO){ setMsg('pastHolidayMsg','Select a past holiday date.'); return null; }
  const winBefore = safeNum($('pastHolidayWinBefore')?.value, 3);
  const winAfter  = safeNum($('pastHolidayWinAfter')?.value, 3);
  const lookback  = safeNum($('pastHolidayLookback')?.value, 84);
  const excludeH  = ($('pastHolidayExcludeHolidays')?.value || "yes") === "yes";
  const skipDay0  = ($('pastHolidaySkipDay0')?.value || "yes") === "yes";
  if(!state.raw || !state.raw.length){ setMsg('pastHolidayMsg','Upload historical data first (Daily import), then analyze.'); return null; }

  const tmpl = computeHolidayTemplate({ name, dateISO, winBefore, winAfter, lookbackDays: lookback, excludeHolidays: excludeH, skipDay0 });

  const pv = $('pastHolidayPreview');
  if(pv){
    const rows = tmpl.effects.slice().sort((a,b)=>a.offset-b.offset).map(e=>{
      const sign = e.offset>0 ? "+" : "";
      return `<tr><td class="text-start">${sign}${e.offset}</td><td class="text-start">${escapeHtml(fmtDateMDY(e.dateISO))}</td><td>${(e.callsMult||1).toFixed(2)}×</td><td>${(e.ahtMult||1).toFixed(2)}×</td></tr>`;
    }).join("");
    pv.innerHTML = `
      <div class="small-muted" style="font-weight:900;margin-bottom:6px;">Learned impact (vs baseline)</div>
      <div class="table-responsive">
        <table class="table table-sm table-bordered">
          <thead><tr><th class="text-start">Offset</th><th class="text-start">Date</th><th>Calls Mult</th><th>AHT Mult</th></tr></thead>
          <tbody>${rows || '<tr><td colspan="4" class="small-muted">No effects learned (check data availability).</td></tr>'}</tbody>
        </table>
      </div>`;
  }

  setMsg('pastHolidayMsg','Analysis complete. You can now “Add Past Holiday”.');
  return tmpl;
}
function renderHolidayIntelUI(){
  const refSel = $('futureHolidayRefPast');
  if(refSel){
    refSel.innerHTML = '';
    const past = state.holidayIntel?.past || [];
    if(!past.length){
      const opt=document.createElement('option');
      opt.value=''; opt.textContent='(Add a Past Holiday first)';
      refSel.appendChild(opt);
    }else{
      const opt0=document.createElement('option');
      opt0.value=''; opt0.textContent='Select a past holiday…';
      refSel.appendChild(opt0);
      past.forEach(p=>{
        const opt=document.createElement('option');
        opt.value=p.id;
        opt.textContent=`${p.name} (${fmtDateMDY(p.dateISO)})`;
        refSel.appendChild(opt);
      });
    }
  }

  const list = $('holidayIntelList');
  if(!list) return;
  const past = state.holidayIntel?.past || [];
  const fut  = state.holidayIntel?.future || [];

  if(!past.length && !fut.length){
    list.innerHTML = `<div class="small-muted">No holiday intelligence added yet.</div>`;
    return;
  }

  const pastHtml = past.map(p=>`
    <div class="border rounded p-2 mb-2 soft-panel">
      <div><strong>Past:</strong> ${escapeHtml(p.name)} • <span class="event-badge">${escapeHtml(fmtDateMDY(p.dateISO))}</span>
        <span class="small-muted"> • window ${p.winBefore} before / ${p.winAfter} after</span></div>
      <div class="small-muted mt-1">Effects learned: ${p.effects?.length || 0} day(s)</div>
      <button class="btn btn-sm btn-outline-danger btn-compact mt-2" data-act="rm-past" data-id="${escapeHtml(p.id)}">Remove</button>
    </div>`).join('');

  const futHtml = fut.map(f=>`
    <div class="border rounded p-2 mb-2 soft-panel">
      <div><strong>Future:</strong> ${escapeHtml(f.name)} • <span class="event-badge">${escapeHtml(fmtDateMDY(f.dateISO))}</span>
        <span class="small-muted"> • applies ${f.spreadBefore} before / ${f.spreadAfter} after • decay ${escapeHtml(f.decay)}</span></div>
      <div class="small-muted mt-1">References: ${escapeHtml(f.refPastName||'')}</div>
      <button class="btn btn-sm btn-outline-danger btn-compact mt-2" data-act="rm-fut" data-id="${escapeHtml(f.id)}">Remove</button>
    </div>`).join('');

  list.innerHTML = `
    <div class="small-muted" style="font-weight:900;">Saved Holiday Intelligence</div>
    <div class="mt-2">${pastHtml || '<div class="small-muted">No Past Holidays stored.</div>'}</div>
    <div class="mt-2">${futHtml || '<div class="small-muted">No Future Holidays stored.</div>'}</div>`;

  list.querySelectorAll('button[data-act="rm-past"]').forEach(btn=>{
    btn.onclick=()=>{
      const id=btn.getAttribute('data-id');
      state.holidayIntel.past = (state.holidayIntel.past||[]).filter(x=>x.id!==id);
      // also remove any futures referencing it
      state.holidayIntel.future = (state.holidayIntel.future||[]).filter(x=>x.refPastId!==id);
      saveHolidayIntel();
      renderHolidayIntelUI();
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
  list.querySelectorAll('button[data-act="rm-fut"]').forEach(btn=>{
    btn.onclick=()=>{
      const id=btn.getAttribute('data-id');
      state.holidayIntel.future = (state.holidayIntel.future||[]).filter(x=>x.id!==id);
      saveHolidayIntel();
      renderHolidayIntelUI();
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
}
function saveHolidayIntel(){
  try{ localStorage.setItem(LS.HOLIDAY_INTEL, JSON.stringify(state.holidayIntel || {past:[],future:[]})); }catch(e){}
}
function loadHolidayIntel(){
  try{
    const raw = localStorage.getItem(LS.HOLIDAY_INTEL);
    if(raw){
      const obj = JSON.parse(raw);
      if(obj && typeof obj === 'object'){
        state.holidayIntel = { past: Array.isArray(obj.past)?obj.past:[], future: Array.isArray(obj.future)?obj.future:[] };
      }
    }
  }catch(e){}
}
function applyHolidayIntelAdjustments(rows){
  if(!rows || !rows.length) return rows;
  const fut = state.holidayIntel?.future || [];
  const past = state.holidayIntel?.past || [];
  if(!fut.length || !past.length) return rows;

  const pastById = new Map(past.map(p=>[p.id,p]));
  const holSet = getHolidaySet();
  const idxByDate = new Map();
  rows.forEach((r,i)=>{ if(r?.date) idxByDate.set(normalizeISODateString(r.date), i); });

  for(const f of fut){
    const p = pastById.get(f.refPastId);
    if(!p) continue;
    const fISO = normalizeISODateString(f.dateISO);
    if(!fISO) continue;

    const spreadBefore = Math.max(0, Math.round(Number(f.spreadBefore)||0));
    const spreadAfter  = Math.max(0, Math.round(Number(f.spreadAfter)||0));
    const maxDist = Math.max(spreadBefore, spreadAfter, 1);
    const decay = f.decay || "linear";

    const effByOffset = new Map();
    (p.effects||[]).forEach(e=>{ if(isFinite(e.offset)) effByOffset.set(Number(e.offset), e); });

    for(let o=-spreadBefore; o<=spreadAfter; o++){
      const tgtISO = normalizeISODateString(addDays(fISO, o));
      if(!tgtISO) continue;
      if(holSet.has(tgtISO)) continue; // keep holiday/closed blank
      const idx = idxByDate.get(tgtISO);
      if(idx===undefined) continue;
      const r = rows[idx];
      if(r.calls===null && r.aht===null) continue;

      let learned = effByOffset.get(o);
      if(!learned){
        let best=null, bestDist=1e9;
        effByOffset.forEach((val,k)=>{ const d=Math.abs(k-o); if(d<bestDist){bestDist=d; best=val;} });
        learned = best;
      }
      if(!learned) continue;

      let callsMult = Number(learned.callsMult)||1;
      let ahtMult = Number(learned.ahtMult)||1;
      if(decay === "linear"){
        const w = 1 - (Math.abs(o)/maxDist);
        callsMult = 1 + (callsMult-1)*w;
        ahtMult = 1 + (ahtMult-1)*w;
      }

      let newCalls = r.calls;
      let newAht = r.aht;
      if(isFinite(newCalls)) newCalls = Math.max(0, newCalls * callsMult);
      if(isFinite(newAht)) newAht = clamp(newAht * ahtMult, 60, 7200);
      rows[idx] = {...r, calls: newCalls, aht: newAht};
    }
  }
  return rows;
}


/* -------------------- HOLIDAY INTELLIGENCE (learn + apply) -------------------- */
function safeNum(n, fallback=null){
  n = Number(n);
  return isFinite(n) ? n : fallback;
}
function mean(arr){
  const a=(arr||[]).filter(x=>isFinite(x));
  if(!a.length) return null;
  return a.reduce((s,v)=>s+v,0)/a.length;
}
function getRawByISO(){
  const m = new Map();
  (state.raw||[]).forEach(r=>{
    const iso = normalizeISODateString(r.date);
    if(!iso) return;
    const calls = safeNum(r.calls, null);
    const aht = safeNum((r.aht_seconds!==undefined ? r.aht_seconds : r.aht), null);
    m.set(iso, { calls, aht });
  });
  return m;
}
function computeHolidayTemplate({name, dateISO, winBefore, winAfter, lookbackDays, excludeHolidays=true, skipDay0=true}){
  const rawMap = getRawByISO();
  const holSet = getHolidaySet();
  const effects = [];
  const wB = Math.max(0, Math.round(Number(winBefore)||0));
  const wA = Math.max(0, Math.round(Number(winAfter)||0));
  const lb = Math.max(14, Math.round(Number(lookbackDays)||56));

  // build baseline pools by DOW in lookback window
  const endISO = normalizeISODateString(addDays(dateISO, -1));
  const startISO = normalizeISODateString(addDays(dateISO, -lb));
  const lbDates = daterange(startISO, endISO);

  const excludeSet = new Set();
  for(let o=-wB; o<=wA; o++){
    excludeSet.add(normalizeISODateString(addDays(dateISO, o)));
  }

  const poolsByDow = Array.from({length:7},()=>({calls:[], aht:[]}));
  lbDates.forEach(iso=>{
    if(excludeSet.has(iso)) return;
    if(excludeHolidays && holSet.has(iso)) return;
    const d = rawMap.get(iso);
    if(!d) return;
    const dow = dowIdxFromISO(iso);
    if(isFinite(d.calls)) poolsByDow[dow].calls.push(d.calls);
    if(isFinite(d.aht)) poolsByDow[dow].aht.push(d.aht);
  });

  for(let o=-wB; o<=wA; o++){
    if(skipDay0 && o===0) continue;

    const iso = normalizeISODateString(addDays(dateISO, o));
    const d = rawMap.get(iso);
    const dow = dowIdxFromISO(iso);

    const baseCalls = mean(poolsByDow[dow].calls);
    const baseAht = mean(poolsByDow[dow].aht);

    let callsMult = 1, ahtMult = 1;
    if(d && isFinite(d.calls) && isFinite(baseCalls) && baseCalls>0){
      callsMult = Math.max(0, d.calls / baseCalls);
    }
    if(d && isFinite(d.aht) && isFinite(baseAht) && baseAht>0){
      ahtMult = clamp(d.aht / baseAht, 0.25, 4.0);
    }
    effects.push({ offset:o, callsMult, ahtMult, dateISO: iso });
  }

  return {
    id: uid("hol"),
    name: String(name||"Holiday").trim() || "Holiday",
    dateISO,
    winBefore: wB,
    winAfter: wA,
    lookbackDays: lb,
    excludeHolidays: !!excludeHolidays,
    skipDay0: !!skipDay0,
    effects
  };
}
function analyzePastHolidayPreview(){
  const name = $('pastHolidayName')?.value;
  const d = $('pastHolidayDate')?.value;
  const dateISO = normalizeISODateString(d);
  if(!dateISO){
    setMsg('pastHolidayMsg', 'Select a past holiday date.');
    return null;
  }
  const winBefore = safeNum($('pastHolidayWinBefore')?.value, 3);
  const winAfter  = safeNum($('pastHolidayWinAfter')?.value, 3);
  const lookback  = safeNum($('pastHolidayLookback')?.value, 84);
  const excludeH  = ($('pastHolidayExcludeHolidays')?.value || "yes") === "yes";
  const skipDay0  = ($('pastHolidaySkipDay0')?.value || "yes") === "yes";

  if(!state.raw || !state.raw.length){
    setMsg('pastHolidayMsg', 'Upload historical data first (Daily import), then analyze.');
    return null;
  }

  const tmpl = computeHolidayTemplate({
    name, dateISO,
    winBefore, winAfter,
    lookbackDays: lookback,
    excludeHolidays: excludeH,
    skipDay0
  });

  // render preview table
  const pv = $('pastHolidayPreview');
  if(pv){
    const rows = tmpl.effects.slice().sort((a,b)=>a.offset-b.offset).map(e=>{
      const sign = e.offset>0 ? "+" : "";
      return `<tr>
        <td class="text-start">${sign}${e.offset}</td>
        <td class="text-start">${escapeHtml(fmtDateMDY(e.dateISO))}</td>
        <td>${(e.callsMult||1).toFixed(2)}×</td>
        <td>${(e.ahtMult||1).toFixed(2)}×</td>
      </tr>`;
    }).join("");
    pv.innerHTML = `
      <div class="small-muted" style="font-weight:900;margin-bottom:6px;">Learned impact (vs baseline)</div>
      <div class="table-responsive">
        <table class="table table-sm table-bordered">
          <thead><tr>
            <th class="text-start">Offset</th>
            <th class="text-start">Date</th>
            <th>Calls Mult</th>
            <th>AHT Mult</th>
          </tr></thead>
          <tbody>${rows || '<tr><td colspan="4" class="small-muted">No effects learned (check data availability).</td></tr>'}</tbody>
        </table>
      </div>
    `;
  }

  setMsg('pastHolidayMsg', 'Analysis complete. You can now “Add Past Holiday”.');
  return tmpl;
}
function renderHolidayIntelUI(){
  const refSel = $('futureHolidayRefPast');
  if(refSel){
    refSel.innerHTML = '';
    const past = state.holidayIntel?.past || [];
    if(!past.length){
      const opt=document.createElement('option');
      opt.value='';
      opt.textContent='(Add a Past Holiday first)';
      refSel.appendChild(opt);
    }else{
      const opt0=document.createElement('option');
      opt0.value='';
      opt0.textContent='Select a past holiday…';
      refSel.appendChild(opt0);
      past.forEach(p=>{
        const opt=document.createElement('option');
        opt.value=p.id;
        opt.textContent=`${p.name} (${fmtDateMDY(p.dateISO)})`;
        refSel.appendChild(opt);
      });
    }
  }

  const list = $('holidayIntelList');
  if(!list) return;
  const past = state.holidayIntel?.past || [];
  const fut  = state.holidayIntel?.future || [];

  if(!past.length && !fut.length){
    list.innerHTML = `<div class="small-muted">No holiday intelligence added yet.</div>`;
    return;
  }

  const pastHtml = past.map((p)=>`
    <div class="border rounded p-2 mb-2 soft-panel">
      <div><strong>Past:</strong> ${escapeHtml(p.name)} • <span class="event-badge">${escapeHtml(fmtDateMDY(p.dateISO))}</span>
        <span class="small-muted"> • window ${p.winBefore} before / ${p.winAfter} after</span>
      </div>
      <div class="small-muted mt-1">Effects learned: ${p.effects?.length || 0} day(s)</div>
      <button class="btn btn-sm btn-outline-danger btn-compact mt-2" data-action="removePast" data-id="${escapeHtml(p.id)}">Remove</button>
    </div>
  `).join("");

  const futHtml = fut.map((f)=>`
    <div class="border rounded p-2 mb-2 soft-panel">
      <div><strong>Future:</strong> ${escapeHtml(f.name)} • <span class="event-badge">${escapeHtml(fmtDateMDY(f.dateISO))}</span>
        <span class="small-muted"> • applies ${f.spreadBefore} before / ${f.spreadAfter} after • decay ${escapeHtml(f.decay)}</span>
      </div>
      <div class="small-muted mt-1">References: ${escapeHtml(f.refPastName||'')}</div>
      <button class="btn btn-sm btn-outline-danger btn-compact mt-2" data-action="removeFuture" data-id="${escapeHtml(f.id)}">Remove</button>
    </div>
  `).join("");

  list.innerHTML = `
    <div class="small-muted" style="font-weight:900;">Saved Holiday Intelligence</div>
    <div class="mt-2">${pastHtml || '<div class="small-muted">No Past Holidays stored.</div>'}</div>
    <div class="mt-2">${futHtml || '<div class="small-muted">No Future Holidays stored.</div>'}</div>
  `;

  list.querySelectorAll('button[data-action="removePast"]').forEach(btn=>{
    btn.onclick = ()=>{
      const id = btn.getAttribute('data-id');
      state.holidayIntel.past = (state.holidayIntel.past||[]).filter(x=>x.id!==id);
      // also remove futures that reference it
      state.holidayIntel.future = (state.holidayIntel.future||[]).filter(x=>x.refPastId!==id);
      saveHolidayIntel();
      renderHolidayIntelUI();
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
  list.querySelectorAll('button[data-action="removeFuture"]').forEach(btn=>{
    btn.onclick = ()=>{
      const id = btn.getAttribute('data-id');
      state.holidayIntel.future = (state.holidayIntel.future||[]).filter(x=>x.id!==id);
      saveHolidayIntel();
      renderHolidayIntelUI();
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
}
function saveHolidayIntel(){
  try{
    localStorage.setItem(LS.HOLIDAY_INTEL, JSON.stringify(state.holidayIntel || {past:[],future:[]}));
  }catch(e){}
}
function loadHolidayIntel(){
  try{
    const raw = localStorage.getItem(LS.HOLIDAY_INTEL);
    if(raw){
      const obj = JSON.parse(raw);
      if(obj && typeof obj === 'object'){
        state.holidayIntel = {
          past: Array.isArray(obj.past) ? obj.past : [],
          future: Array.isArray(obj.future) ? obj.future : []
        };
      }
    }
  }catch(e){}
}
function applyHolidayIntelAdjustments(rows){
  if(!rows || !rows.length) return rows;
  const fut = state.holidayIntel?.future || [];
  const past = state.holidayIntel?.past || [];
  if(!fut.length || !past.length) return rows;

  const pastById = new Map(past.map(p=>[p.id,p]));
  const holSet = getHolidaySet();

  const idxByDate = new Map();
  rows.forEach((r, i)=>{ if(r?.date) idxByDate.set(normalizeISODateString(r.date), i); });

  for(const f of fut){
    const p = pastById.get(f.refPastId);
    if(!p) continue;

    const fISO = normalizeISODateString(f.dateISO);
    if(!fISO) continue;

    const spreadBefore = Math.max(0, Math.round(Number(f.spreadBefore)||0));
    const spreadAfter  = Math.max(0, Math.round(Number(f.spreadAfter)||0));
    const maxDist = Math.max(spreadBefore, spreadAfter, 1);
    const decay = f.decay || "linear";

    // Build lookup of learned effects by offset
    const effByOffset = new Map();
    (p.effects||[]).forEach(e=>{ if(isFinite(e.offset)) effByOffset.set(Number(e.offset), e); });

    for(let o=-spreadBefore; o<=spreadAfter; o++){
      const tgtISO = normalizeISODateString(addDays(fISO, o));
      if(!tgtISO) continue;
      if(holSet.has(tgtISO)) continue; // do not override closed/holiday blanks
      const idx = idxByDate.get(tgtISO);
      if(idx===undefined) continue;

      const r = rows[idx];
      if(r.calls===null && r.aht===null) continue;

      let learned = effByOffset.get(o);
      if(!learned){
        let best=null, bestDist=1e9;
        effByOffset.forEach((val, k)=>{
          const d=Math.abs(k-o);
          if(d<bestDist){ bestDist=d; best=val; }
        });
        learned = best;
      }
      if(!learned) continue;

      let callsMult = Number(learned.callsMult)||1;
      let ahtMult = Number(learned.ahtMult)||1;

      if(decay==="linear"){
        const w = 1 - (Math.abs(o)/maxDist);
        callsMult = 1 + (callsMult-1)*w;
        ahtMult = 1 + (ahtMult-1)*w;
      }

      let newCalls = r.calls;
      let newAht = r.aht;

      if(isFinite(newCalls)) newCalls = Math.max(0, newCalls * callsMult);
      if(isFinite(newAht)) newAht = clamp(newAht * ahtMult, 60, 7200);

      rows[idx] = {...r, calls: newCalls, aht: newAht};
    }
  }
  return rows;
}

/* -------------------- ERLANG C INPUTS -------------------- */
function getErlangInputs(){
  return {
    svTarget: Number($('svTarget')?.value) || 80,
    asaTarget: Number($('asaTarget')?.value) || 20,
    occupancy: Number($('occupancy')?.value) || 85,
    shrinkage: Number($('shrinkage')?.value) || 30,
    intradayDev: Number($('intradayDev')?.value) || 0
  };
}
function setErlangInputs(obj){
  if(!obj) return;
  if($('svTarget')) $('svTarget').value = obj.svTarget ?? 80;
  if($('asaTarget')) $('asaTarget').value = obj.asaTarget ?? 20;
  if($('occupancy')) $('occupancy').value = obj.occupancy ?? 85;
  if($('shrinkage')) $('shrinkage').value = obj.shrinkage ?? 30;
  if($('intradayDev')) $('intradayDev').value = obj.intradayDev ?? 0;
}
function saveErlang(){
  localStorage.setItem(LS.ERLANG, JSON.stringify(getErlangInputs()));
  showPill('erlangStatus');
  setMsg('erlangMsg', 'Saved to this browser.');
}
function loadErlang(){
  const raw = localStorage.getItem(LS.ERLANG);
  if(!raw) return false;
  try{ setErlangInputs(JSON.parse(raw)); setMsg('erlangMsg','Loaded saved settings.'); return true; }catch{ return false; }
}

/* -------------------- HOOP PARSING -------------------- */
function parseTimeHHMM(s){
  const m = String(s||"").trim().match(/^(\d{1,2}):(\d{2})$/);
  if(!m) return null;
  const hh = Number(m[1]), mm = Number(m[2]);
  if(!Number.isFinite(hh) || !Number.isFinite(mm) || hh<0 || hh>23 || mm<0 || mm>59) return null;
  return hh*60 + mm;
}
function dayKeyFromToken(tok){
  const t0 = String(tok||"").trim().toLowerCase();
  if(!t0) return null;
  const t = t0.replace(/[.,]/g,"");
  if(t.startsWith("mon")) return "monday";
  if(t.startsWith("tue")) return "tuesday";
  if(t.startsWith("wed")) return "wednesday";
  if(t.startsWith("thu")) return "thursday";
  if(t.startsWith("fri")) return "friday";
  if(t.startsWith("sat")) return "saturday";
  if(t.startsWith("sun")) return "sunday";
  return null;
}
function expandDayRange(startKey, endKey){
  const si = DAY_KEYS.indexOf(startKey);
  const ei = DAY_KEYS.indexOf(endKey);
  if(si<0 || ei<0) return [];
  const out = [];
  let i = si;
  while(true){
    out.push(DAY_KEYS[i]);
    if(i === ei) break;
    i = (i+1) % DAY_KEYS.length;
    if(out.length > 7) break;
  }
  return out;
}
function parseDaysToKeys(daysStr){
  const raw = String(daysStr||"").trim();
  if(!raw) return [];
  const cleaned = raw.replaceAll("–","-").replaceAll("—","-").replace(/\s+/g," ").trim();
  const parts = cleaned.split(/[;|]/).map(x=>x.trim()).filter(Boolean);

  const keys = new Set();
  for(const part0 of parts){
    const part = part0.replace(/,/g," ").replace(/\s+/g," ").trim();
    if(!part) continue;

    const rangeMatch = part.match(/^([A-Za-z.]+)\s*-\s*([A-Za-z.]+)$/);
    if(rangeMatch){
      const a = dayKeyFromToken(rangeMatch[1]);
      const b = dayKeyFromToken(rangeMatch[2]);
      if(a && b){
        expandDayRange(a,b).forEach(k=>keys.add(k));
        continue;
      }
    }

    const tokens = part.split(/\s+/).map(x=>x.trim()).filter(Boolean);
    for(const tok of tokens){
      const dk = dayKeyFromToken(tok);
      if(dk) keys.add(dk);
    }
  }
  return Array.from(keys);
}
function buildHoopWindows(){
  const win = {};
  DAY_KEYS.forEach(k => win[k] = []);
  (state.hoops || []).forEach(h=>{
    const dayKeys = parseDaysToKeys(h.days);
    const fromMin = parseTimeHHMM(h.from);
    const toMin   = parseTimeHHMM(h.to);
    if(!dayKeys.length || fromMin===null || toMin===null) return;

    let a = fromMin, b = toMin;
    if(b <= a){ const tmp=a; a=b; b=tmp; }

    const fromC = Math.max(START_MIN, Math.min(END_MIN, a));
    const toC   = Math.max(START_MIN, Math.min(END_MIN, b));
    if(toC <= fromC) return;

    dayKeys.forEach(dk=> win[dk].push({fromMin: fromC, toMin: toC}));
  });

  DAY_KEYS.forEach(dk=>{
    const arr = win[dk].slice().sort((x,y)=>x.fromMin - y.fromMin);
    const merged = [];
    for(const w of arr){
      if(!merged.length){ merged.push({...w}); continue; }
      const last = merged[merged.length-1];
      if(w.fromMin <= last.toMin) last.toMin = Math.max(last.toMin, w.toMin);
      else merged.push({...w});
    }
    win[dk] = merged;
  });

  return win;
}
function idxIsOpenForDay(dayKey, idx, windows){
  const tStart = START_MIN + idx*INTERVAL_MIN;
  return (windows[dayKey]||[]).some(w => tStart >= w.fromMin && tStart < w.toMin);
}
function getOpenIdxsForDay(dayKey, windows){
  const idxs = [];
  for(let i=0;i<INTERVALS;i++){
    if(idxIsOpenForDay(dayKey, i, windows)) idxs.push(i);
  }
  return idxs;
}
function hasAnyHoopWindows(windows){
  return DAY_KEYS.some(dk => (windows[dk]||[]).length > 0);
}
function normalizeDayTo100(dayKey, windows){
  const openIdx = getOpenIdxsForDay(dayKey, windows);
  for(let i=0;i<INTERVALS;i++){
    if(!openIdx.includes(i)){
      state.intraday[dayKey][i] = null;
    }
  }
  if(!openIdx.length) return;

  let sum = 0;
  openIdx.forEach(i=>{
    const v = Number(state.intraday[dayKey][i]);
    const vv = (Number.isFinite(v) && v>=0) ? v : 0;
    state.intraday[dayKey][i] = vv;
    sum += vv;
  });

  if(sum <= 0){
    const even = 100 / openIdx.length;
    openIdx.forEach(i => state.intraday[dayKey][i] = even);
    return;
  }

  const scale = 100 / sum;
  openIdx.forEach(i => state.intraday[dayKey][i] = (Number(state.intraday[dayKey][i])||0) * scale);
}
function applyHoopToIntraday(){
  const windows = buildHoopWindows();
  const hasAny = hasAnyHoopWindows(windows);

  if(!hasAny){
    refreshIntradayInputs();
    renderIntradayTotals();
    return;
  }

  DAY_KEYS.forEach(dk=>{
    if(!(windows[dk]||[]).length){
      state.intraday[dk] = Array.from({length:INTERVALS}, ()=>null);
    }else{
      normalizeDayTo100(dk, windows);
    }
  });

  refreshIntradayInputs();
  renderIntradayTotals();
  setMsg('intradayMsg', 'Intraday matched to business days/hours (outside HOOP is blank; inside totals = 100%).');
}

/* -------------------- BLANK NON-BUSINESS DAYS / NO-INTRADAY DAYS -------------------- */
function hasUsableIntradayForDay(dayKey, windows){
  const openIdx = getOpenIdxsForDay(dayKey, windows);
  if(!openIdx.length) return false;
  const arr = state.intraday[dayKey] || [];
  return openIdx.some(i => Number.isFinite(Number(arr[i])));
}
function applyNonBusinessDayBlanks(rows){
  const windows = buildHoopWindows();
  const hasAny = hasAnyHoopWindows(windows);

  return rows.map(r=>{
    const iso = normalizeISODateString(r.date);
    if(!iso) return r;

    if(!hasAny){
      return r;
    }

    const dk = dayKeyFromDowIdx(dowIdxFromISO(iso));
    const openIdx = getOpenIdxsForDay(dk, windows);

    if(!openIdx.length){
      return {...r, calls: null, aht: null, servers: null, staffing: null};
    }

    if(!hasUsableIntradayForDay(dk, windows)){
      return {...r, calls: null, aht: null, servers: null, staffing: null};
    }

    return r;
  });
}

/* -------------------- HOOP UI + SAVE -------------------- */
function renderHoops(){
  const container = $('hoopList');
  if(!container) return;
  container.innerHTML = '';
  if(!state.hoops.length){
    container.innerHTML = '<div class="small-muted">No HOOP entries yet.</div>';
    return;
  }
  state.hoops.forEach((h, idx)=>{
    const div = document.createElement('div');
    div.className='border rounded p-2 mb-2 hoop-entry';
    div.innerHTML = `
      <div><strong>Days:</strong> ${escapeHtml(h.days)} — <strong>HOOP:</strong> ${escapeHtml(hhmmToTime12(h.from))} - ${escapeHtml(hhmmToTime12(h.to))}</div>
      <button class="btn btn-sm btn-outline-danger btn-compact mt-1">Remove</button>
    `;
    container.appendChild(div);
    div.querySelector('button').onclick = ()=>{
      state.hoops.splice(idx, 1);
      renderHoops();
      applyHoopToIntraday();
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
}

/* HOOP ENTRY CONTROLS */
const hoopUi = {
  selectedDayKeys: new Set(["monday","tuesday","wednesday","thursday","friday"]),
  timeOptions: buildTimeOptions(30)
};
function updateDaysDropdownLabel(){
  const btn = $('daysDropdownBtn');
  if(!btn) return;
  const keys = Array.from(hoopUi.selectedDayKeys);
  if(!keys.length){
    btn.textContent = "Select days…";
    return;
  }
  const labels = keys
    .slice()
    .sort((a,b)=> DAY_KEYS.indexOf(a) - DAY_KEYS.indexOf(b))
    .map(k => DAY_LABELS[DAY_KEYS.indexOf(k)]);
  btn.textContent = labels.join(", ");
}
function renderDaysDropdownMenu(){
  const menu = $('daysDropdownMenu');
  if(!menu) return;
  menu.innerHTML = "";

  DAY_KEYS.forEach((k, i)=>{
    const item = document.createElement('div');
    item.className = "days-item";
    item.innerHTML = `
      <input class="form-check-input" type="checkbox" id="dayChk_${k}" ${hoopUi.selectedDayKeys.has(k) ? "checked" : ""}>
      <label class="form-check-label" for="dayChk_${k}" style="cursor:pointer;">${escapeHtml(DAY_LABELS[i])}</label>
    `;
    menu.appendChild(item);

    const cb = item.querySelector('input');
    cb.addEventListener('change', ()=>{
      if(cb.checked) hoopUi.selectedDayKeys.add(k);
      else hoopUi.selectedDayKeys.delete(k);
      updateDaysDropdownLabel();
    });

    item.addEventListener('click', (ev)=>{
      if(ev.target && ev.target.tagName?.toLowerCase() === "input") return;
      cb.checked = !cb.checked;
      cb.dispatchEvent(new Event('change'));
    });
  });

  updateDaysDropdownLabel();
}
function populateTimeSelect(selId, defaultVal){
  const sel = $(selId);
  if(!sel) return;
  sel.innerHTML = "";
  hoopUi.timeOptions.forEach(o=>{
    const opt = document.createElement('option');
    opt.value = o.value;
    opt.textContent = o.label;
    sel.appendChild(opt);
  });
  if(defaultVal) sel.value = defaultVal;
}
function clearHoopEntry(){
  hoopUi.selectedDayKeys = new Set(["monday","tuesday","wednesday","thursday","friday"]);
  renderDaysDropdownMenu();
  if($('hoopStartSel')) $('hoopStartSel').value = "07:00";
  if($('hoopEndSel')) $('hoopEndSel').value = "20:00";
  setMsg('hoopEntryMsg', '');
}
function saveHoops(){
  localStorage.setItem(LS.HOOP, JSON.stringify(state.hoops));
  showPill('hoopStatus');
  setMsg('hoopMsg', 'Saved to this browser.');
  applyHoopToIntraday();
  ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
}
function loadHoops(){
  const raw = localStorage.getItem(LS.HOOP);
  if(!raw) return false;
  try{
    const arr = JSON.parse(raw);
    state.hoops = Array.isArray(arr) ? arr : [];
    renderHoops();
    setMsg('hoopMsg', 'Loaded saved HOOP entries.');
    return true;
  }catch{ return false; }
}

/* -------------------- HOLIDAYS SAVE -------------------- */
function renderHolidayList(){
  const ul = $('holList');
  if(!ul) return;
  ul.innerHTML = '';
  state.holidays.slice().sort().forEach(d=>{
    const li = document.createElement('li');
    li.className='list-group-item d-flex justify-content-between align-items-center';
    li.style.background = "rgba(255,255,255,.85)";
    li.style.borderColor = "rgba(15,23,42,.12)";
    li.style.color = "rgba(15,23,42,.92)";
    li.innerHTML = `${escapeHtml(d)} <button class='btn btn-sm btn-danger btn-compact'>x</button>`;
    ul.appendChild(li);
    li.querySelector('button').onclick = ()=>{
      state.holidays = state.holidays.filter(x=>x!==d);
      renderHolidayList();
      ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    };
  });
}
function saveHolidays(){
  const normalized = (state.holidays||[]).map(normalizeISODateString).filter(Boolean);
  state.holidays = Array.from(new Set(normalized));
  localStorage.setItem(LS.HOLIDAYS, JSON.stringify(state.holidays));
  showPill('holidayStatus');
  setMsg('holidayMsg', 'Saved to this browser.');
  renderHolidayList();
  ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
}
function loadHolidays(){
  const raw = localStorage.getItem(LS.HOLIDAYS);
  if(!raw) return false;
  try{
    const arr = JSON.parse(raw);
    const normalized = (Array.isArray(arr) ? arr : []).map(normalizeISODateString).filter(Boolean);
    state.holidays = Array.from(new Set(normalized));
    renderHolidayList();
    setMsg('holidayMsg','Loaded saved holidays.');
    return true;
  }catch{ return false; }
}

/* -------------------- INTRADAY GRID -------------------- */
function buildIntradayTable(){
  const table = $('intradayTable');
  if(!table) return;
  table.innerHTML = "";

  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  const th0 = document.createElement('th');
  th0.innerText = "Time";
  trh.appendChild(th0);

  DAY_LABELS.forEach(lbl=>{
    const th = document.createElement('th');
    th.innerText = lbl;
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  for(let i=0;i<INTERVALS;i++){
    const tStart = START_MIN + i*INTERVAL_MIN;
    const tr = document.createElement('tr');

    const tdTime = document.createElement('td');
    tdTime.innerText = minutesToTime12(tStart);
    tr.appendChild(tdTime);

    DAY_KEYS.forEach((dayKey)=>{
      const td = document.createElement('td');
      const inp = document.createElement('input');
      inp.type = "number";
      inp.step = "0.1";
      inp.min = "0";
      inp.className = "form-control form-control-sm pct-input";
      inp.dataset.day = dayKey;
      inp.dataset.idx = String(i);

      const v0 = state.intraday[dayKey][i];
      inp.value = (v0===null || v0===undefined) ? "" : v0;
      inp.placeholder = "%";

      inp.addEventListener('change', ()=>{
        if(inp.disabled) return;
        const idx = Number(inp.dataset.idx);
        const dk = inp.dataset.day;
        const v = parseFloat(inp.value);
        state.intraday[dk][idx] = (isFinite(v) && v>=0) ? v : 0;

        const windows = buildHoopWindows();
        const hasAny = hasAnyHoopWindows(windows);
        if(hasAny){
          normalizeDayTo100(dk, windows);
          refreshIntradayInputs();
        }else{
          renderIntradayTotals();
        }

        ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
      });

      td.appendChild(inp);
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  }
  table.appendChild(tbody);

  const anySet = DAY_KEYS.some(k => (state.intraday[k]||[]).some(v => (Number(v)||0) > 0));
  if(!anySet){
    const pct = 100 / INTERVALS;
    DAY_KEYS.forEach(k=> state.intraday[k] = Array.from({length:INTERVALS}, ()=>pct));
  }

  refreshIntradayInputs();
}
function refreshIntradayInputs(){
  const table = $('intradayTable');
  const tbody = table?.querySelector('tbody');
  if(!tbody) return;

  const windows = buildHoopWindows();
  const hasAny = hasAnyHoopWindows(windows);

  const rows = Array.from(tbody.querySelectorAll('tr'));
  rows.forEach((tr, i)=>{
    const tds = Array.from(tr.querySelectorAll('td'));
    for(let d=0; d<DAY_KEYS.length; d++){
      const dayKey = DAY_KEYS[d];
      const inp = tds[d+1].querySelector('input');

      const open = hasAny ? idxIsOpenForDay(dayKey, i, windows) : true;

      if(!open){
        inp.value = "";
        inp.disabled = true;
        inp.classList.add("pct-disabled");
      }else{
        inp.disabled = false;
        inp.classList.remove("pct-disabled");
        const v = state.intraday[dayKey][i];
        inp.value = (v===null || v===undefined) ? "" : (Math.round(Number(v)*10)/10);
      }
    }
  });

  renderIntradayTotals();
}
function renderIntradayTotals(){
  const el = $('intradayTotals');
  if(!el) return;
  const windows = buildHoopWindows();
  const hasAny = hasAnyHoopWindows(windows);
  const parts = DAY_KEYS.map((k,idx)=>{
    let sum = 0;
    if(!hasAny){
      sum = (state.intraday[k]||[]).slice(0,INTERVALS).reduce((a,b)=>a+(Number(b)||0),0);
    }else{
      const openIdx = getOpenIdxsForDay(k, windows);
      openIdx.forEach(i=>{
        const v = Number(state.intraday[k]?.[i]);
        if(Number.isFinite(v)) sum += v;
      });
    }
    return `${DAY_LABELS[idx]}: ${Math.round(sum*10)/10}%`;
  });
  el.innerText = parts.join(" • ");
}

/* -------------------- INTRADAY SAVE/LOAD -------------------- */
function saveIntraday(){
  localStorage.setItem(LS.INTRADAY, JSON.stringify(state.intraday));
  showPill('intradayStatus');
  setMsg('intradayMsg', 'Saved to this browser.');
}
function loadIntraday(){
  const raw = localStorage.getItem(LS.INTRADAY);
  if(!raw) return false;
  try{
    const obj = JSON.parse(raw);
    if(obj && typeof obj === 'object'){
      DAY_KEYS.forEach(k=>{
        const arr = Array.isArray(obj[k]) ? obj[k] : [];
        state.intraday[k] = Array.from({length:INTERVALS}, (_,i)=> (i < arr.length ? arr[i] : null));
      });
      setMsg('intradayMsg','Loaded saved intraday pattern.');
      return true;
    }
  }catch{}
  return false;
}

/* -------------------- FILE PARSING -------------------- */
function handleFile(e){
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    const data = ev.target.result;
    let workbook;
    try{
      workbook = XLSX.read(data, {type: 'binary'});
    }catch(err){
      const txt = new TextDecoder().decode(data);
      processCSV(txt);
      return;
    }
    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
    const json = XLSX.utils.sheet_to_json(firstSheet, {raw:false});
    processUploaded(json);
  };
  reader.readAsBinaryString(file);
}
function processCSV(txt){
  const arr = XLSX.read(txt, {type:'string', raw:false});
  const json = XLSX.utils.sheet_to_json(arr.Sheets[arr.SheetNames[0]]);
  processUploaded(json);
}
function processUploaded(json){
  const rows = json.map(r=>{
    const keys = Object.keys(r);
    const map = {};
    keys.forEach(k=> map[k.toLowerCase().trim()] = r[k]);

    const dateVal = map.date || map.datetime || map.timestamp || map['date/time'] || map['date time'];
    let dt = dateVal ? new Date(dateVal) : null;

    const calls = Number(map.calls ?? map.call_volume ?? map.volume ?? map['historical call volume'] ?? map['historical call volume ']) || Number(map['#calls']) || 0;
    const aht = Number(map.aht || map['aht_seconds'] || map['aht secs'] || map.aht_seconds) || 0;

    if(!dt && map.time){ dt = new Date(map.time); }
    return {date: dt? new Date(dt.toDateString()): null, calls, aht};
  });

  const filtered = rows.filter(r => r.date && !isNaN(r.date) && (r.calls>0 || r.aht>0));
  const daily = {};
  filtered.forEach(r=>{
    const key = r.date.toISOString().slice(0,10);
    if(!daily[key]) daily[key] = {date: new Date(key), calls:0, ahtSum:0, ahtCount:0};
    daily[key].calls += r.calls;
    if(r.aht>0 && r.calls>0){ daily[key].ahtSum += r.aht * r.calls; daily[key].ahtCount += r.calls; }
  });

  const arr = Object.values(daily)
    .map(d=> ({date:d.date, calls:d.calls, aht: d.ahtCount? Math.round(d.ahtSum/d.ahtCount): 0}))
    .sort((a,b)=>a.date-b.date);

  state.raw = {daily: arr};

  if(arr.length){
    const start = toISODate(addDays(arr[arr.length-1].date, 1));
    const end = toISODate(addDays(arr[arr.length-1].date, 31));
    if(!$('startDate')?.value) $('startDate').value = start;
    if(!$('endDate')?.value) $('endDate').value = end;
  }

  setText('preview', `Loaded ${arr.length} daily rows.`);
  setMsg('genMsg','');

  if((state.events?.past?.length||0) > 0){
    setMsg('pastEventMsg', 'Historical data loaded. You can Analyze past events now.');
  }
}

/* -------------------- AHT FALLBACK (WEIGHTED) -------------------- */
function computeFallbackAHTSeconds(hist){
  if(!hist || !hist.length) return 0;
  const lastDate = hist[hist.length-1].date;
  const cutoff = addDays(lastDate, -60);

  const recent = hist.filter(r => r.date >= cutoff && (r.calls||0)>0 && (r.aht||0)>0);
  const use = recent.length ? recent : hist.filter(r => (r.calls||0)>0 && (r.aht||0)>0);

  let num=0, den=0;
  use.forEach(r=>{
    const c = Number(r.calls)||0;
    const a = Number(r.aht)||0;
    if(c>0 && a>0){ num += a*c; den += c; }
  });
  return den ? Math.round(num/den) : 0;
}

/* -------------------- ERLANG C CORE -------------------- */
function erlangC_Pw(A, N){
  if(N <= 0) return 1;
  if(A < 0) return 1;
  if(A === 0) return 0;
  if(N <= A) return 1;
  let sum = 0;
  let term = 1;
  sum += term;
  for(let k=1;k<=N-1;k++){
    term = term * (A / k);
    sum += term;
  }
  const last = term * (A / N);
  const top = last * (N / (N - A));
  const denom = sum + top;
  return denom ? (top / denom) : 1;
}
function erlangC_serviceLevel(A, N, AHT, ASA){
  if(AHT <= 0) return 0;
  if(ASA < 0) return 0;
  if(N <= A) return 0;
  const Pw = erlangC_Pw(A, N);
  const expo = Math.exp(-(N - A) * (ASA / AHT));
  return 1 - Pw * expo;
}
function requiredAgentsErlangC({callsInterval, intervalSeconds, ahtSeconds, svTargetPct, asaSeconds}){
  const c = Math.max(0, Number(callsInterval)||0);
  if(c <= 0) return 0;
  const lam = c / intervalSeconds;
  const A = lam * ahtSeconds;
  if(A <= 0) return 0;
  const target = (svTargetPct||0) / 100;
  const maxN = Math.min(5000, Math.max(200, Math.ceil(A + 200)));
  let N = Math.max(1, Math.ceil(A));
  while(N < maxN){
    if(N > A){
      const sl = erlangC_serviceLevel(A, N, ahtSeconds, asaSeconds);
      if(sl >= target) return N;
    }
    N++;
  }
  return maxN;
}

/* -------------------- STAFFING (PEAK INTERVAL) -------------------- */
function computePeakStaffingForDay({dateISO, dailyCalls, ahtSeconds}){
  if(dailyCalls === null || dailyCalls === undefined || !isFinite(dailyCalls) || dailyCalls <= 0){
    return { servers: null, staffing: null };
  }
  const windows = buildHoopWindows();
  const hasAny = hasAnyHoopWindows(windows);

  const dk = dayKeyFromDowIdx(dowIdxFromISO(dateISO));
  const openIdx = hasAny ? getOpenIdxsForDay(dk, windows) : Array.from({length:INTERVALS},(_,i)=>i);

  if(!openIdx.length) return { servers: null, staffing: null };
  if(hasAny && !hasUsableIntradayForDay(dk, windows)) return { servers: null, staffing: null };

  const er = getErlangInputs();
  const svTargetPct = er.svTarget;
  const asaSeconds = er.asaTarget;
  const occTarget = clamp(er.occupancy || 85, 1, 100) / 100;
  const shrink = clamp(er.shrinkage || 0, 0, 99.9) / 100;

  const weights = openIdx.map(i=>{
    const v = state.intraday[dk]?.[i];
    const vv = (v===null || v===undefined) ? 0 : Number(v)||0;
    return Math.max(0, vv);
  });
  let wsum = weights.reduce((a,b)=>a+b,0);
  if(wsum <= 0){
    const even = 100 / openIdx.length;
    for(let j=0;j<weights.length;j++) weights[j] = even;
    wsum = 100;
  }

  let peakNoShrink = 0;
  for(let j=0;j<openIdx.length;j++){
    const frac = weights[j] / wsum;
    const callsInterval = dailyCalls * frac;
    const N = requiredAgentsErlangC({
      callsInterval,
      intervalSeconds: INTERVAL_SECONDS,
      ahtSeconds,
      svTargetPct,
      asaSeconds
    });
    const Nocc = occTarget > 0 ? Math.ceil(N / occTarget) : N;
    if(Nocc > peakNoShrink) peakNoShrink = Nocc;
  }

  const servers = peakNoShrink;
  const staffing = (1 - shrink) > 0 ? Math.ceil(servers / (1 - shrink)) : servers;
  return { servers, staffing };
}


/* -------------------- INTRADAY FILE PARSING (Day / Interval / Calls) -------------------- */
function normalizeDayNameToKey(dayVal){
  const s = String(dayVal||"").trim().toLowerCase();
  if(!s) return null;
  const map = {
    "mon":"monday","monday":"monday",
    "tue":"tuesday","tues":"tuesday","tuesday":"tuesday",
    "wed":"wednesday","weds":"wednesday","wednesday":"wednesday",
    "thu":"thursday","thur":"thursday","thurs":"thursday","thursday":"thursday",
    "fri":"friday","friday":"friday",
    "sat":"saturday","saturday":"saturday",
    "sun":"sunday","sunday":"sunday"
  };
  return map[s] || null;
}
function parseIntervalToMinutes(val){
  const s0 = String(val||"").trim();
  if(!s0) return null;

  // accept "8:30 AM" / "08:30" / "8:30" / "20:00"
  const s = s0.replace(/\s+/g," ").toUpperCase();

  let m = s.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/);
  if(m){
    let hh = Number(m[1]), mm = Number(m[2]);
    if(!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
    if(hh<1 || hh>12 || mm<0 || mm>59) return null;
    const ampm = m[3];
    if(ampm==="AM"){
      if(hh===12) hh=0;
    }else{
      if(hh!==12) hh += 12;
    }
    return hh*60 + mm;
  }

  m = s.match(/^(\d{1,2}):(\d{2})$/);
  if(m){
    const hh = Number(m[1]), mm = Number(m[2]);
    if(!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
    if(hh<0 || hh>23 || mm<0 || mm>59) return null;
    return hh*60 + mm;
  }

  // Excel times sometimes arrive as "8:30:00 AM"
  m = s.match(/^(\d{1,2}):(\d{2}):\d{2}\s*(AM|PM)$/);
  if(m){
    return parseIntervalToMinutes(`${m[1]}:${m[2]} ${m[3]}`);
  }
  m = s.match(/^(\d{1,2}):(\d{2}):\d{2}$/);
  if(m){
    return parseIntervalToMinutes(`${m[1]}:${m[2]}`);
  }

  // As a last resort, try Date parsing
  const d = new Date(s0);
  if(!isNaN(d)){
    return d.getHours()*60 + d.getMinutes();
  }
  return null;
}
function round2(n){
  const x = Number(n);
  if(!isFinite(x)) return 0;
  return Math.round(x*100)/100;
}

function handleIntradayFile(e){
  const file = e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = function(ev){
    const data = ev.target.result;
    let workbook;
    try{
      workbook = XLSX.read(data, {type: 'binary'});
    }catch(err){
      const txt = new TextDecoder().decode(data);
      processIntradayCSV(txt);
      return;
    }
    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
    const json = XLSX.utils.sheet_to_json(firstSheet, {raw:false});
    processIntradayUploaded(json);
  };
  reader.readAsBinaryString(file);
}

function processIntradayCSV(txt){
  const arr = XLSX.read(txt, {type:'string', raw:false});
  const json = XLSX.utils.sheet_to_json(arr.Sheets[arr.SheetNames[0]]);
  processIntradayUploaded(json);
}

function processIntradayUploaded(json){
  try{
    if(!Array.isArray(json) || !json.length){
      setMsg('intradayPreview', 'No rows found in the Intraday file.');
      return;
    }

    // Reset intraday to nulls (we will refill from import)
    DAY_KEYS.forEach(dk => state.intraday[dk] = Array.from({length:INTERVALS}, ()=>null));

    // Group by day, calculate daily totals, then compute % per interval
    const dayToMap = new Map(); // dayKey -> Map(idx -> calls)
    const dayTotals = new Map(); // dayKey -> total calls

    json.forEach(r=>{
      const keys = Object.keys(r||{});
      const map = {};
      keys.forEach(k=> map[k.toLowerCase().trim()] = r[k]);

      const dayVal = map.day ?? map['day of week'] ?? map.dow ?? map.weekday;
      const intervalVal = map.interval ?? map.time ?? map['time interval'] ?? map['half hour'] ?? map['half-hour'];
      const callsVal = map.calls ?? map.call ?? map.volume ?? map['call volume'] ?? map['call_volume'];

      const dayKey = normalizeDayNameToKey(dayVal);
      const mins = parseIntervalToMinutes(intervalVal);
      const calls = Number(callsVal);

      if(!dayKey || !Number.isFinite(mins) || !Number.isFinite(calls)) return;

      // Convert to table index (fixed window 5:00 AM–10:00 PM, 30-min)
      if(mins < START_MIN || mins >= END_MIN) return;
      const idx = Math.floor((mins - START_MIN) / INTERVAL_MIN);
      if(idx < 0 || idx >= INTERVALS) return;

      if(!dayToMap.has(dayKey)) dayToMap.set(dayKey, new Map());
      const m = dayToMap.get(dayKey);
      m.set(idx, (m.get(idx) || 0) + calls);

      dayTotals.set(dayKey, (dayTotals.get(dayKey) || 0) + calls);
    });

    let daysLoaded = 0;
    let rowsUsed = 0;

    DAY_KEYS.forEach(dk=>{
      const total = dayTotals.get(dk) || 0;
      const m = dayToMap.get(dk);
      if(!m || total <= 0) return;

      daysLoaded += 1;
      m.forEach((c, idx)=>{
        rowsUsed += 1;
        // % of day (0-100)
        state.intraday[dk][idx] = round2((c / total) * 100);
      });
    });

    // After import, ensure HOOP blanking + normalize within HOOP (keeps distribution)
    applyHoopToIntraday();

    // Helpful preview
    const msg = daysLoaded
      ? `Imported intraday actuals for ${daysLoaded} day(s). Updated the Intraday Pattern table.`
      : `No valid intraday rows found. (Make sure Day/Interval/Calls are populated and intervals are within 5:00 AM–10:00 PM.)`;
    setMsg('intradayPreview', msg);

    // Optional: auto-save so it persists like other settings
    localStorage.setItem(LS.INTRADAY, JSON.stringify(state.intraday));
    setMsg('intradayMsg', daysLoaded ? 'Intraday import applied and saved to this browser.' : 'Intraday import found no usable rows.');
  }catch(err){
    setMsg('intradayPreview', 'Intraday import failed: ' + (err?.message || 'Unknown error'));
  }
}


/* -------------------- API DATA SOURCE -------------------- */
function apiSetPill(text, ok){
  const pill = $('apiStatusPill');
  if(!pill) return;
  pill.textContent = text || '';
  pill.style.background = ok ? 'rgba(16,185,129,.12)' : 'rgba(148,163,184,.25)';
  pill.style.borderColor = ok ? 'rgba(16,185,129,.35)' : 'rgba(148,163,184,.35)';
  pill.style.color = ok ? 'rgba(5,150,105,1)' : 'rgba(15,23,42,.7)';
}

function apiReadForm(){
  const st = $('apiSourceType')?.value || 'rest';
  const url = $('apiProxyUrl')?.value || '';
  const authType = $('apiAuthType')?.value || 'none';
  const authValue = $('apiAuthValue')?.value || '';
  const headersJson = $('apiHeadersJson')?.value || '';
  state.api.sourceType = st;
  state.api.proxyUrl = url.trim();
  state.api.authType = authType;
  state.api.authValue = authValue;
  state.api.headersJson = headersJson;
}

function apiWriteForm(){
  if($('apiSourceType')) $('apiSourceType').value = state.api.sourceType || 'rest';
  if($('apiProxyUrl')) $('apiProxyUrl').value = state.api.proxyUrl || '';
  if($('apiAuthType')) $('apiAuthType').value = state.api.authType || 'none';
  if($('apiAuthValue')) $('apiAuthValue').value = state.api.authValue || '';
  if($('apiHeadersJson')) $('apiHeadersJson').value = state.api.headersJson || '';
}

function apiSaveSettings(){
  apiReadForm();
  localStorage.setItem(LS.API_SETTINGS, JSON.stringify(state.api));
  setMsg('apiMsg', 'Saved API settings to this browser.');
  renderApiPreview();
}

function apiLoadSettings(){
  try{
    const raw = localStorage.getItem(LS.API_SETTINGS);
    if(raw){
      const v = JSON.parse(raw);
      state.api = Object.assign(state.api, v || {});
    }
  }catch(e){}
  apiWriteForm();
}

function apiSaveCache(){
  try{
    localStorage.setItem(LS.API_CACHE, JSON.stringify({
      daily: state.apiCache.daily,
      intraday: state.apiCache.intraday,
      lastSync: state.api.lastSync
    }));
  }catch(e){}
}

function apiLoadCache(){
  try{
    const raw = localStorage.getItem(LS.API_CACHE);
    if(raw){
      const v = JSON.parse(raw);
      state.apiCache.daily = v?.daily || null;
      state.apiCache.intraday = v?.intraday || null;
      if(v?.lastSync) state.api.lastSync = v.lastSync;
    }
  }catch(e){}
}

function apiClearAll(){
  state.api = { sourceType:"rest", proxyUrl:"", authType:"none", authValue:"", headersJson:"", lastSync:null };
  state.apiCache = { daily:null, intraday:null };
  try{ localStorage.removeItem(LS.API_SETTINGS); }catch(e){}
  try{ localStorage.removeItem(LS.API_CACHE); }catch(e){}
  apiWriteForm();
  apiSetPill('Not connected', false);
  setMsg('apiMsg','Cleared API settings and cached API data from this browser.');
  renderApiPreview();
}

function apiBuildHeaders(){
  const headers = {};
  // auth
  const t = (state.api.authType || 'none');
  const v = (state.api.authValue || '').trim();
  if(v){
    if(t === 'bearer') headers['Authorization'] = 'Bearer ' + v;
    if(t === 'apikey') headers['x-api-key'] = v;
  }
  // extra headers json
  const extraRaw = (state.api.headersJson || '').trim();
  if(extraRaw){
    try{
      const extra = JSON.parse(extraRaw);
      if(extra && typeof extra === 'object'){
        Object.keys(extra).forEach(k=>{
          headers[String(k)] = String(extra[k]);
        });
      }
    }catch(e){
      throw new Error('Extra headers JSON is invalid.');
    }
  }
  return headers;
}

async function apiTestConnection(){
  apiReadForm();
  if(!state.api.proxyUrl){
    setMsg('apiMsg','Enter a Proxy / API URL first.');
    return;
  }
  try{
    setMsg('apiMsg','Testing connection…');
    const headers = apiBuildHeaders();
    const res = await fetch(state.api.proxyUrl, { method:'GET', headers });
    if(!res.ok){
      throw new Error('HTTP ' + res.status + ' ' + res.statusText);
    }
    setMsg('apiMsg','Connection OK. (Tip: Click "Fetch Data" to load daily/intraday into the tool.)');
    apiSetPill('Connected', true);
  }catch(err){
    apiSetPill('Not connected', false);
    setMsg('apiMsg','Test failed: ' + (err?.message || String(err)));
  }
}

function apiNormalizeDailyRows(dailyRows){
  const daily = {};
  (dailyRows || []).forEach(r=>{
    if(!r) return;
    const ds = (r.date || r.Date || r.dt || r.day || r.Day || '').toString().slice(0,10);
    const d = normalizeISODateString(ds);
    if(!d) return;

    const calls = Number(r.calls ?? r.Calls ?? r.call_volume ?? r.volume ?? 0) || 0;
    const aht = Number(r.aht_seconds ?? r.aht ?? r.ahtSeconds ?? r.AHT ?? r.handle_time_seconds ?? 0) || 0;

    if(!daily[d]) daily[d] = { date: new Date(d), calls:0, ahtSum:0, ahtCount:0 };
    daily[d].calls += calls;
    if(aht>0 && calls>0){ daily[d].ahtSum += aht * calls; daily[d].ahtCount += calls; }
  });

  const arr = Object.values(daily)
    .map(d=> ({date:d.date, calls:d.calls, aht: d.ahtCount ? Math.round(d.ahtSum/d.ahtCount) : 0}))
    .sort((a,b)=>a.date-b.date);

  return arr;
}

function apiApplyDailyToTool(arr){
  state.raw = { daily: arr };
  if(arr.length){
    const start = toISODate(addDays(arr[arr.length-1].date, 1));
    const end = toISODate(addDays(arr[arr.length-1].date, 31));
    if(!$('startDate')?.value) $('startDate').value = start;
    if(!$('endDate')?.value) $('endDate').value = end;
  }
  setText('preview', `Loaded ${arr.length} daily rows. (Source: API)`);
  setMsg('genMsg','');
}

function apiParseIntervalToMinutes(s){
  if(s==null) return null;
  const str = String(s).trim();
  if(!str) return null;
  // Accept "HH:MM", "H:MM AM/PM"
  const m = str.match(/^(\d{1,2}):(\d{2})(?:\s*([AaPp][Mm]))?$/);
  if(!m) return null;
  let hh = Number(m[1]), mm = Number(m[2]);
  const ampm = m[3] ? m[3].toLowerCase() : null;
  if(ampm){
    if(hh===12) hh = 0;
    if(ampm==='pm') hh += 12;
  }
  if(hh<0 || hh>23 || mm<0 || mm>59) return null;
  return hh*60 + mm;
}

function apiNormalizeDayKey(day){
  const d = String(day||'').trim().toLowerCase();
  if(!d) return null;
  const map = {
    mon:'monday', monday:'monday',
    tue:'tuesday', tues:'tuesday', tuesday:'tuesday',
    wed:'wednesday', weds:'wednesday', wednesday:'wednesday',
    thu:'thursday', thur:'thursday', thurs:'thursday', thursday:'thursday',
    fri:'friday', friday:'friday',
    sat:'saturday', saturday:'saturday',
    sun:'sunday', sunday:'sunday'
  };
  return map[d] || null;
}

function apiApplyIntradayToTool(intraRows){
  if(!intraRows || !intraRows.length) return;

  // replicate intraday import behavior: convert actuals to % of day within 5:00–22:00, 30-min
  const START_MIN = 5*60;
  const END_MIN = 22*60;
  const INTERVAL_MIN = 30;
  const INTERVALS = Math.floor((END_MIN-START_MIN)/INTERVAL_MIN); // 34
  const DAY_KEYS = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];

  // ensure arrays exist
  DAY_KEYS.forEach(dk=>{
    if(!Array.isArray(state.intraday[dk]) || state.intraday[dk].length !== INTERVALS){
      state.intraday[dk] = Array.from({length:INTERVALS}, ()=>0);
    }
  });

  const dayToMap = new Map();
  const dayTotals = new Map();

  intraRows.forEach(r=>{
    if(!r) return;
    const dk = apiNormalizeDayKey(r.day ?? r.Day ?? r.dow ?? r.DOW);
    if(!dk) return;
    const mins = apiParseIntervalToMinutes(r.interval ?? r.Interval ?? r.time ?? r.Time);
    if(mins==null) return;
    const calls = Number(r.calls ?? r.Calls ?? r.volume ?? 0) || 0;
    if(calls<=0) return;

    if(mins < START_MIN || mins >= END_MIN) return;
    const idx = Math.floor((mins - START_MIN) / INTERVAL_MIN);
    if(idx < 0 || idx >= INTERVALS) return;

    if(!dayToMap.has(dk)) dayToMap.set(dk, new Map());
    const mm = dayToMap.get(dk);
    mm.set(idx, (mm.get(idx) || 0) + calls);
    dayTotals.set(dk, (dayTotals.get(dk) || 0) + calls);
  });

  let daysLoaded = 0;
  DAY_KEYS.forEach(dk=>{
    const total = dayTotals.get(dk) || 0;
    const mm = dayToMap.get(dk);
    if(!mm || total<=0) return;
    daysLoaded += 1;
    mm.forEach((c, idx)=>{
      state.intraday[dk][idx] = round2((c / total) * 100);
    });
  });

  applyHoopToIntraday();
  localStorage.setItem(LS.INTRADAY, JSON.stringify(state.intraday));

  setMsg('intradayPreview', daysLoaded
    ? `Imported intraday actuals for ${daysLoaded} day(s). Updated the Intraday Pattern table. (Source: API)`
    : `No valid intraday rows found from API.`);

  setMsg('intradayMsg', daysLoaded ? 'Intraday pattern saved to this browser.' : 'API intraday found no usable rows.');
}

async function apiFetchAndApply(){
  apiReadForm();
  if(!state.api.proxyUrl){
    setMsg('apiMsg','Enter a Proxy / API URL first.');
    return;
  }
  try{
    setMsg('apiMsg','Fetching API data…');
    const headers = apiBuildHeaders();
    const res = await fetch(state.api.proxyUrl, { method:'GET', headers });
    if(!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);

    const ct = (res.headers.get('content-type')||'').toLowerCase();
    let payload = null;

    if(ct.includes('application/json') || ct.includes('text/json') || ct.includes('+json')){
      payload = await res.json();
    }else{
      // attempt json anyway
      const txt = await res.text();
      try{ payload = JSON.parse(txt); }catch(e){
        throw new Error('API response is not JSON. Please return JSON {daily:[...], intraday:[...]} from your proxy.');
      }
    }

    const dailyRows = payload?.daily || payload?.Daily || payload?.data || payload?.rows || [];
    const intradayRows = payload?.intraday || payload?.Intraday || payload?.intra || [];

    const dailyArr = apiNormalizeDailyRows(dailyRows);
    if(!dailyArr.length){
      throw new Error('No usable daily rows returned. Expected fields: date, calls, aht_seconds.');
    }

    // Apply to tool
    apiApplyDailyToTool(dailyArr);

    // Save cache & optional intraday
    state.apiCache.daily = dailyRows;
    state.apiCache.intraday = intradayRows && intradayRows.length ? intradayRows : null;

    if(state.apiCache.intraday){
      apiApplyIntradayToTool(state.apiCache.intraday);
    }

    state.api.lastSync = new Date().toISOString();
    apiSaveSettings();
    apiSaveCache();

    apiSetPill('Connected • Synced', true);
    setMsg('apiMsg', `Fetched ${dailyArr.length} daily row(s)${state.apiCache.intraday ? ' + intraday' : ''}. Applied to tool.`);
    renderApiPreview();
  }catch(err){
    apiSetPill('Not connected', false);
    setMsg('apiMsg','Fetch failed: ' + (err?.message || String(err)));
  }
}

function renderApiPreview(){
  const metaEl = $('apiDataMeta');
  const tblEl = $('apiDataTable');
  const msgEl = $('apiDataMsg');

  if(metaEl) metaEl.textContent = '';
  if(tblEl) tblEl.innerHTML = '';
  if(msgEl) msgEl.textContent = '';

  // Basic meta
  const url = state.api.proxyUrl || '';
  const last = state.api.lastSync ? new Date(state.api.lastSync) : null;
  const lastTxt = last && !isNaN(last) ? last.toLocaleString() : '—';

  const cacheDaily = state.apiCache?.daily;
  const cacheIntra = state.apiCache?.intraday;

  const dailyArr = cacheDaily ? apiNormalizeDailyRows(cacheDaily) : (state.raw?.daily || []);
  const range = dailyArr.length ? `${toISODate(dailyArr[0].date)} → ${toISODate(dailyArr[dailyArr.length-1].date)}` : '—';

  if(metaEl){
    metaEl.innerHTML = `
      <div><span class="pill">Source: ${escapeHtml(state.api.sourceType||'rest')}</span>
      <span class="pill">Last sync: ${escapeHtml(lastTxt)}</span>
      <span class="pill">Daily rows: ${escapeHtml(String(dailyArr.length||0))}</span>
      <span class="pill">Range: ${escapeHtml(range)}</span></div>
      <div class="mt-1 small-muted">Endpoint: <code>${escapeHtml(url || '—')}</code></div>
    `;
  }

  if(!dailyArr.length){
    if(msgEl) msgEl.textContent = 'No API data cached yet. Go to Data Source → API and click “Fetch Data”.';
    return;
  }

  // Build preview table (first 50)
  const preview = dailyArr.slice(0, 50).map(r=>({
    date: toISODate(r.date),
    calls: r.calls,
    aht: r.aht
  }));

  if(tblEl){
    tblEl.innerHTML = `
      <div class="table-responsive">
        <table class="table table-sm table-bordered forecast-table">
          <thead><tr>
            <th style="width:140px">Date</th>
            <th style="width:120px">Calls</th>
            <th style="width:120px">AHT (sec)</th>
          </tr></thead>
          <tbody>
            ${preview.map(r=>`
              <tr>
                <td><span class="pill">${escapeHtml(r.date)}</span></td>
                <td>${fmtInt(r.calls)}</td>
                <td>${fmtInt(r.aht)}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>
      ${cacheIntra && cacheIntra.length ? `<div class="small-muted mt-2">Intraday rows in cache: ${escapeHtml(String(cacheIntra.length))}</div>` : ''}
    `;
  }
}

function syncDataSourceMode(){
  // Disable uploads when API tab is active (prevents confusion)
  const apiActive = !!document.querySelector('#dataSourceTabs .nav-link.active[data-bs-target="#ds-api"]');
  const fi = $('fileInput');
  const fii = $('intradayFileInput');
  if(fi) fi.disabled = apiActive;
  if(fii) fii.disabled = apiActive;
}

/* -------------------- FORECAST HELPERS -------------------- */
function holtWintersAdditive(y, seasonLen=7, alpha=0.35, beta=0.08, gamma=0.20){
  const n = y.length;
  if(n < seasonLen*2){
    const mean = y.reduce((a,b)=>a+b,0)/Math.max(1,y.length);
    return { forecast: (h)=>Array.from({length:h},()=>mean) };
  }
  const avg1 = y.slice(0,seasonLen).reduce((a,b)=>a+b,0)/seasonLen;
  const avg2 = y.slice(seasonLen,seasonLen*2).reduce((a,b)=>a+b,0)/seasonLen;
  let level = avg1;
  let trend = (avg2-avg1)/seasonLen;
  const season = Array(seasonLen).fill(0).map((_,i)=> y[i]-avg1);
  for(let t=0; t<n; t++){
    const s = season[t % seasonLen];
    const lastLevel = level;
    level = alpha*(y[t]-s) + (1-alpha)*(level+trend);
    trend = beta*(level-lastLevel) + (1-beta)*trend;
    season[t % seasonLen] = gamma*(y[t]-level) + (1-gamma)*s;
  }
  return {
    forecast: (h)=>{
      const out=[];
      for(let k=1;k<=h;k++){
        const s = season[(n+k-1)%seasonLen];
        out.push(Math.max(0, level + k*trend + s));
      }
      return out;
    }
  };
}

/* --------- Additional Time Series Models (Auto-select) --------- */
function simpleExpSmoothing(y, alpha=0.35){
  let level = y[0];
  for(let t=1;t<y.length;t++){
    const v = y[t];
    level = alpha*v + (1-alpha)*level;
  }
  return {
    forecast: (h)=>Array.from({length:h}, ()=>level)
  };
}
function holtLinear(y, alpha=0.35, beta=0.10){
  if(y.length<2) return { forecast:(h)=>Array.from({length:h},()=>y[0]??0) };
  let level = y[0];
  let trend = y[1]-y[0];
  for(let t=1;t<y.length;t++){
    const v = y[t];
    const prevLevel = level;
    level = alpha*v + (1-alpha)*(level+trend);
    trend = beta*(level-prevLevel) + (1-beta)*trend;
  }
  return {
    forecast:(h)=>Array.from({length:h}, (_,i)=>level + (i+1)*trend)
  };
}

// Prophet-like (Lite): linear trend + weekly seasonality via Fourier terms
function prophetLiteFitForecast(y, horizon, period=7, K=3){
  const n = y.length;
  if(n < Math.max(14, period*2)){
    const mean = y.reduce((a,b)=>a+b,0)/Math.max(1,n);
    return { forecast:Array.from({length:horizon},()=>mean) };
  }
  // Design matrix columns: [1, t, sin/cos(k*2πt/period)]
  const cols = 2 + 2*K;
  const X = Array.from({length:n}, (_,i)=>{
    const t = i;
    const row = new Array(cols).fill(0);
    row[0]=1;
    row[1]=t;
    for(let k=1;k<=K;k++){
      const ang = 2*Math.PI*k*t/period;
      row[2+(k-1)*2]   = Math.sin(ang);
      row[2+(k-1)*2+1] = Math.cos(ang);
    }
    return row;
  });

  // Solve beta = (X'X)^-1 X'y via Gaussian elimination (normal equations)
  const XtX = Array.from({length:cols}, ()=>new Array(cols).fill(0));
  const Xty = new Array(cols).fill(0);
  for(let i=0;i<n;i++){
    const xi = X[i];
    for(let a=0;a<cols;a++){
      Xty[a] += xi[a]*y[i];
      for(let b=0;b<cols;b++){
        XtX[a][b] += xi[a]*xi[b];
      }
    }
  }
  // Augment
  const A = XtX.map((row,i)=>row.concat([Xty[i]]));
  // Eliminate
  for(let i=0;i<cols;i++){
    // pivot
    let pivot=i;
    for(let r=i+1;r<cols;r++){
      if(Math.abs(A[r][i])>Math.abs(A[pivot][i])) pivot=r;
    }
    if(Math.abs(A[pivot][i]) < 1e-10) continue;
    if(pivot!==i){ const tmp=A[i]; A[i]=A[pivot]; A[pivot]=tmp; }
    const div = A[i][i];
    for(let c=i;c<=cols;c++) A[i][c] /= div;
    for(let r=0;r<cols;r++){
      if(r===i) continue;
      const factor = A[r][i];
      if(Math.abs(factor)<1e-12) continue;
      for(let c=i;c<=cols;c++){
        A[r][c] -= factor*A[i][c];
      }
    }
  }
  const beta = A.map(row=>row[cols] ?? 0);

  const forecast = [];
  for(let h=1;h<=horizon;h++){
    const t = (n-1)+h;
    let yhat = beta[0] + beta[1]*t;
    for(let k=1;k<=K;k++){
      const ang = 2*Math.PI*k*t/period;
      yhat += beta[2+(k-1)*2]*Math.sin(ang) + beta[2+(k-1)*2+1]*Math.cos(ang);
    }
    forecast.push(yhat);
  }
  return { forecast };
}

function arimaForecastAuto(y, horizon){
  // arima@1.0.9 exposes global ARIMA constructor in most builds.
  // We'll grid-search small (p,d,q) and pick lowest AIC-like proxy (via validation MAPE).
  if(typeof ARIMA === "undefined"){
    const mean = y.reduce((a,b)=>a+b,0)/Math.max(1,y.length);
    return { forecast:Array.from({length:horizon},()=>mean), ok:false };
  }
  const candidates = [
    {p:1,d:0,q:1},{p:2,d:0,q:2},{p:3,d:0,q:1},
    {p:1,d:1,q:1},{p:2,d:1,q:2},{p:3,d:1,q:1},
  ];
  let best=null;
  for(const c of candidates){
    try{
      const model = new ARIMA({p:c.p, d:c.d, q:c.q, verbose:false}).train(y);
      const [pred] = model.predict(horizon);
      if(!pred || !pred.length) continue;
      best = { forecast: pred, ok:true, name:`ARIMA(${c.p},${c.d},${c.q})` };
      break; // first successful; we'll rely on outer backtest selection
    }catch(e){
      // try next
    }
  }
  if(!best){
    const mean = y.reduce((a,b)=>a+b,0)/Math.max(1,y.length);
    return { forecast:Array.from({length:horizon},()=>mean), ok:false };
  }
  return best;
}

function mape(actual, pred){
  let num=0, den=0, cnt=0;
  for(let i=0;i<actual.length;i++){
    const a = actual[i];
    const p = pred[i];
    if(a===null || a===undefined || !isFinite(a) || a===0) continue;
    if(p===null || p===undefined || !isFinite(p)) continue;
    num += Math.abs((a-p)/a);
    cnt++;
  }
  return cnt ? (num/cnt)*100 : 9999;
}

// Day-of-week scaling to handle missing calendar days (e.g., no Sundays in history)
function computeDowRatios(hist, field="calls"){
  const sums = new Array(7).fill(0);
  const cnts = new Array(7).fill(0);
  for(const r of hist){
    const d = new Date(r.date);
    if(!isFinite(d)) continue;
    const v = Number(r[field]);
    if(!isFinite(v) || v===null) continue;
    // Keep zeros (closed days) for calls; for AHT ignore zeros
    if(field==="aht" && v<=0) continue;
    const dow = d.getDay(); // 0 Sun .. 6 Sat
    sums[dow] += v;
    cnts[dow] += 1;
  }
  const avgs = sums.map((s,i)=> cnts[i] ? (s/cnts[i]) : null);
  const overall = avgs.filter(v=>v!==null).reduce((a,b)=>a+b,0) / Math.max(1,avgs.filter(v=>v!==null).length);
  const ratios = avgs.map(v=> (v!==null && overall>0) ? (v/overall) : 1);
  return { ratios, avgs, overall };
}

function applyDowRatiosToForecast(baseForecast, dates, hist, field="calls"){
  if(!baseForecast || !dates || !dates.length) return baseForecast;
  const { ratios } = computeDowRatios(hist, field);
  // adjust each forecast point by its DOW ratio, then re-scale to preserve total level
  const adjusted = baseForecast.map((v,i)=>{
    const d = new Date(dates[i]);
    const dow = isFinite(d) ? d.getDay() : 1;
    const r = ratios[dow] ?? 1;
    return (Number(v)||0) * r;
  });
  const sumBase = baseForecast.reduce((a,b)=>a+(Number(b)||0),0);
  const sumAdj  = adjusted.reduce((a,b)=>a+(Number(b)||0),0);
  const scale = (sumAdj>0) ? (sumBase/sumAdj) : 1;
  return adjusted.map(v=>v*scale);
}


// One-step rolling backtest for model selection
function autoSelectTimeSeriesModel(y){
  const n = y.length;
  const testLen = Math.min(56, Math.max(14, Math.floor(n*0.20))); // up to 8 weeks, at least 2 weeks
  const start = Math.max(14, n - testLen);
  const models = [
    { key:"HW", name:"Holt-Winters (Additive)", fit:(train, h)=>holtWintersAdditive(train,7).forecast(h) },
    { key:"HOLT", name:"Holt Linear Trend", fit:(train, h)=>holtLinear(train).forecast(h) },
    { key:"SES", name:"Exponential Smoothing", fit:(train, h)=>simpleExpSmoothing(train).forecast(h) },
    { key:"PROPHET", name:"Prophet (Lite: Trend+Weekly)", fit:(train, h)=>prophetLiteFitForecast(train, h, 7, 3).forecast },
    { key:"ARIMA", name:"ARIMA (Auto)", fit:(train, h)=>arimaForecastAuto(train, h).forecast },
  ].filter(m=> m.key!=="ARIMA" || (typeof ARIMA!=="undefined"));

  const scores = models.map(m=>({key:m.key, name:m.name, errs:[]}));
  for(let t=start; t<n; t++){
    const train = y.slice(0,t);
    const actual = [y[t]];
    for(const s of scores){
      const mdl = models.find(mm=>mm.key===s.key);
      let predVal = null;
      try{
        const pred = mdl.fit(train, 1);
        predVal = Array.isArray(pred) ? pred[0] : pred;
      }catch(e){
        predVal = null;
      }
      s.errs.push({a: actual[0], p: predVal});
    }
  }
  scores.forEach(s=>{
    const act = s.errs.map(e=>e.a);
    const prd = s.errs.map(e=>e.p);
    s.mape = mape(act, prd);
  });
  scores.sort((a,b)=>a.mape-b.mape);
  return { best: scores[0], all: scores };
}

function timeSeriesForecastAuto(y, horizon){
  const sel = autoSelectTimeSeriesModel(y);
  const bestKey = sel.best?.key || "HW";
  let forecast=null;
  let modelName = sel.best?.name || "Holt-Winters (Additive)";
  try{
    if(bestKey==="HW") forecast = holtWintersAdditive(y,7).forecast(horizon);
    else if(bestKey==="HOLT") forecast = holtLinear(y).forecast(horizon);
    else if(bestKey==="SES") forecast = simpleExpSmoothing(y).forecast(horizon);
    else if(bestKey==="PROPHET") forecast = prophetLiteFitForecast(y, horizon, 7, 3).forecast;
    else if(bestKey==="ARIMA"){
      const ar = arimaForecastAuto(y, horizon);
      forecast = ar.forecast;
      if(ar.name) modelName = ar.name;
    }
  }catch(e){
    forecast = holtWintersAdditive(y,7).forecast(horizon);
    modelName = "Holt-Winters (Additive)";
  }
  return { forecast, modelName, mape: sel.best?.mape ?? null, all: sel.all };
}

function computeDOWAdditiveEffect(seriesByDow){
  const avgs = seriesByDow.map(arr=>{
    if(!arr.length) return 0;
    return arr.reduce((a,b)=>a+b,0)/arr.length;
  });
  const overall = avgs.reduce((a,b)=>a+b,0)/avgs.length;
  const off = avgs.map(a => a - overall);
  const meanOff = off.reduce((a,b)=>a+b,0)/off.length;
  return off.map(x => x - meanOff);
}
function regressionForecastAdditive(histVals, histDatesISO, futureISOs){
  const y = histVals.map(v=>Number(v)||0);
  const n = y.length;
  const xbar = (n-1)/2;
  const ybar = y.reduce((a,b)=>a+b,0)/Math.max(1,n);

  let num=0, den=0;
  for(let i=0;i<n;i++){
    num += (i-xbar)*(y[i]-ybar);
    den += (i-xbar)*(i-xbar);
  }
  const b1 = den ? (num/den) : 0;
  const b0 = ybar - b1*xbar;

  const byDow = Array.from({length:7},()=>[]);
  for(let i=0;i<n;i++){
    const dow = dowIdxFromISO(histDatesISO[i]);
    byDow[dow].push(y[i]);
  }
  const dowOff = computeDOWAdditiveEffect(byDow);

  const out = [];
  const baseIdxStart = n;
  futureISOs.forEach((iso, j)=>{
    const idx = baseIdxStart + j;
    const base = Math.max(0, b0 + b1*idx);
    const dow = dowIdxFromISO(iso);
    out.push(Math.max(0, base + (dowOff[dow] || 0)));
  });
  return out;
}
async function aiForecastTF_1D(histVals, histDatesISO, futureISOs){
  const y = histVals.map(v=>Number(v)||0);
  const n = y.length;
  if(n < 30){
    return regressionForecastAdditive(histVals, histDatesISO, futureISOs);
  }
  const maxY = Math.max(1, ...y);
  const xs = [];
  const ys = [];
  for(let i=0;i<n;i++){
    const t = i/(n-1);
    const dow = dowIdxFromISO(histDatesISO[i]);
    const ang = 2*Math.PI*(dow/7);
    xs.push([t, Math.sin(ang), Math.cos(ang)]);
    ys.push([y[i]/maxY]);
  }

  const xTensor = tf.tensor2d(xs);
  const yTensor = tf.tensor2d(ys);

  const model = tf.sequential();
  model.add(tf.layers.dense({units:16, activation:'relu', inputShape:[3]}));
  model.add(tf.layers.dense({units:8, activation:'relu'}));
  model.add(tf.layers.dense({units:1, activation:'linear'}));
  model.compile({optimizer: tf.train.adam(0.02), loss:'meanSquaredError'});
  await model.fit(xTensor, yTensor, {epochs: 80, batchSize: 16, verbose: 0});

  const baseIdxStart = n;
  const futX = futureISOs.map((iso,j)=>{
    const t = (baseIdxStart + j)/(n-1);
    const dow = dowIdxFromISO(iso);
    const ang = 2*Math.PI*(dow/7);
    return [t, Math.sin(ang), Math.cos(ang)];
  });

  const pred = model.predict(tf.tensor2d(futX));
  const arr = await pred.data();
  tf.dispose([xTensor,yTensor,model,pred]);

  return Array.from(arr).map(v => Math.max(0, v*maxY));
}

/* -------------------- OPENAI FORECAST (via Proxy) --------------------
   Proxy should return JSON:
   {
     "calls": [..length..],
     "aht": [..length..]
   }
*/
async function openAIForecastViaProxy({histDatesISO, callsHist, ahtHist, futureISOs}){
  const url = (state.openai.proxyUrl || "").trim();
  if(!url){
    throw new Error("OpenAI proxy URL is empty. Add it in OpenAI Forecast Settings.");
  }
  const payload = {
    model: state.openai.model || null,
    temperature: state.openai.temp ?? 0.2,
    historical: histDatesISO.map((d,i)=>({date:d, calls: Number(callsHist[i])||0, aht: Number(ahtHist[i])||0})),
    future_dates: futureISOs
  };
  const res = await fetch(url, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error("Proxy error " + res.status + ": " + t.slice(0,200));
  }
  const data = await res.json();
  if(!data || !Array.isArray(data.calls) || !Array.isArray(data.aht)){
    throw new Error("Proxy response missing arrays: calls[] and aht[].");
  }
  if(data.calls.length !== futureISOs.length || data.aht.length !== futureISOs.length){
    throw new Error("Proxy arrays must match forecast horizon length.");
  }
  return {calls: data.calls, aht: data.aht};
}

/* -------------------- MONTHLY SUMMARY + TABLE RENDER -------------------- */
function buildMonthlySummaries(rows){
  const groups = {};
  (rows || []).forEach(r=>{
    if(!r || r.date===undefined || r.date===null) return;

    // Normalize date aggressively so monthly grouping always works
    // Supports: YYYY-MM-DD, MM-DD-YYYY, MM/DD/YYYY, ISO w/ time, and Date objects.
    let iso = "";
    if(r.date instanceof Date && !isNaN(r.date)){
      iso = toISODate(r.date);
    }else{
      iso = normalizeISODateString(r.date);
      if(!iso){
        const d = new Date(String(r.date));
        if(!isNaN(d)) iso = toISODate(d);
      }
    }

    const mk = monthKeyFromISO(iso || r.date);
    if(!mk) return;
    if(!groups[mk]) groups[mk] = [];
    groups[mk].push(r);
  });
  const keys = Object.keys(groups).sort();
  return keys.map(k=>({monthKey:k, label: monthLabelFromKey(k), rows: groups[k]}));
}

function summarizeMonthRows(monthRows){
  const usable = (monthRows||[]).filter(r=> r && r.calls!==null && r.calls!==undefined);
  const totalCalls = usable.reduce((a,r)=> a + (Number(r.calls)||0), 0);

  let ahtNum = 0, ahtDen = 0;
  usable.forEach(r=>{
    const c = Number(r.calls)||0;
    const a = Number(r.aht)||0;
    if(c>0 && a>0){
      ahtNum += a*c;
      ahtDen += c;
    }
  });
  const avgAht = ahtDen ? (ahtNum / ahtDen) : null;

  const usableServers = usable.filter(r=> r.servers!==null && r.servers!==undefined);
  const usableStaff   = usable.filter(r=> r.staffing!==null && r.staffing!==undefined);

  const avgServers = usableServers.length ? (usableServers.reduce((a,r)=>a+(Number(r.servers)||0),0)/usableServers.length) : null;
  const avgStaff   = usableStaff.length ? (usableStaff.reduce((a,r)=>a+(Number(r.staffing)||0),0)/usableStaff.length) : null;

  return { totalCalls, avgAht, avgServers, avgStaff, days: usable.length };
}
function renderMonthlySummaryHTML(rows){
  const months = buildMonthlySummaries(rows);
  if(!months.length) return "";
  const cards = months.map(m=>{
    const s = summarizeMonthRows(m.rows);
    return `
      <div class="sum-card">
        <div class="sum-title">${escapeHtml(m.label)} Summary</div>
        <div class="sum-grid">
          <div class="sum-k">Forecast Calls (Total)</div>
          <div class="sum-v">${fmtInt(s.totalCalls)}</div>

          <div class="sum-k">AHT (Avg, sec)</div>
          <div class="sum-v">${s.avgAht===null ? "" : fmtInt(s.avgAht)}</div>

          <div class="sum-k">FTE Need (Avg, No Shr.)</div>
          <div class="sum-v">${s.avgServers===null ? "" : fmtInt(s.avgServers)}</div>

          <div class="sum-k">FTE Need (Avg, Shr.)</div>
          <div class="sum-v">${s.avgStaff===null ? "" : fmtInt(s.avgStaff)}</div>

          <div class="sum-k">Days Included</div>
          <div class="sum-v"><span class="pill">${fmtInt(s.days)}</span></div>
        </div>
      </div>
    `;
  }).join("");
  return `<div class="forecast-summary">${cards}</div>`;
}

/* -------------------- MONTHLY FORECAST TAB (aggregated from Daily) -------------------- */
function summarizeMonthForTable(monthRows){
  const usable = (monthRows||[]).filter(r=> r && r.calls!==null && r.calls!==undefined);
  const daysIncluded = usable.length;
  const totalCalls = usable.reduce((a,r)=> a + (Number(r.calls)||0), 0);

  // Weighted avg AHT by calls (fallback to simple avg if calls sum=0)
  const ahtPairs = usable
    .filter(r=> r.aht!==null && r.aht!==undefined && isFinite(Number(r.aht)))
    .map(r=>({aht:Number(r.aht)||0, calls: Math.max(0, Number(r.calls)||0)}));

  let avgAht = null;
  const callWeight = ahtPairs.reduce((a,p)=>a+p.calls,0);
  if(ahtPairs.length){
    if(callWeight > 0){
      avgAht = ahtPairs.reduce((a,p)=>a + p.aht*p.calls, 0) / callWeight;
    }else{
      avgAht = ahtPairs.reduce((a,p)=>a + p.aht, 0) / ahtPairs.length;
    }
  }

  // Avg daily FTE across included days (not sum), based on daily tables
  const fteNoShrArr = usable.map(r=> Number(r.servers)).filter(v=>isFinite(v));
  const fteShrArr   = usable.map(r=> Number(r.staffing)).filter(v=>isFinite(v));
  const avgFteNoShr = fteNoShrArr.length ? (fteNoShrArr.reduce((a,b)=>a+b,0)/fteNoShrArr.length) : null;
  const avgFteShr   = fteShrArr.length   ? (fteShrArr.reduce((a,b)=>a+b,0)/fteShrArr.length)   : null;

  return {
    totalCalls,
    avgAht,
    avgFteNoShr,
    avgFteShr,
    daysIncluded
  };
}

function buildYearSummariesFromMonthly(monthItems){
  const byYear = {};
  (monthItems||[]).forEach(mi=>{
    if(!mi || !mi.monthKey) return;
    const y = String(mi.monthKey).slice(0,4);
    if(!byYear[y]) byYear[y] = [];
    byYear[y].push(mi);
  });
  const years = Object.keys(byYear).sort();
  return years.map(y=>{
    const arr = byYear[y] || [];
    const totals = arr.reduce((acc, mi)=>{
      const s = mi.summary || {};
      acc.calls += Number(s.totalCalls)||0;
      acc.days += Number(s.daysIncluded)||0;

      // For AHT + FTE, compute weighted blend by days included (since monthly AHT already weighted by calls)
      if(isFinite(Number(s.avgAht))){
        acc.ahtSum += Number(s.avgAht) * (Number(s.daysIncluded)||0);
        acc.ahtW += (Number(s.daysIncluded)||0);
      }
      if(isFinite(Number(s.avgFteNoShr))){
        acc.noShrSum += Number(s.avgFteNoShr) * (Number(s.daysIncluded)||0);
        acc.noShrW += (Number(s.daysIncluded)||0);
      }
      if(isFinite(Number(s.avgFteShr))){
        acc.shrSum += Number(s.avgFteShr) * (Number(s.daysIncluded)||0);
        acc.shrW += (Number(s.daysIncluded)||0);
      }
      return acc;
    }, {calls:0, days:0, ahtSum:0, ahtW:0, noShrSum:0, noShrW:0, shrSum:0, shrW:0});

    const yAvgAht = totals.ahtW ? (totals.ahtSum / totals.ahtW) : null;
    const yNoShr  = totals.noShrW ? (totals.noShrSum / totals.noShrW) : null;
    const yShr    = totals.shrW ? (totals.shrSum / totals.shrW) : null;

    return {year:y, totalCalls: totals.calls, avgAht: yAvgAht, avgFteNoShr: yNoShr, avgFteShr: yShr, daysIncluded: totals.days};
  });
}

function renderMonthlyForecastTable(containerId, dailyRows){
  const el = $(containerId);
  if(!el) return;

  const groups = buildMonthlySummaries(dailyRows || []);
  const monthItems = groups.map(g=>{
    const sum = summarizeMonthForTable(g.rows);
    return { monthKey: g.monthKey, label: g.label, summary: sum };
  });

  const yearItems = buildYearSummariesFromMonthly(monthItems);

  const ytdHtml = yearItems.length ? `
    <div class="glass-subcard mb-2">
      <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
        <div style="font-weight:900;letter-spacing:-0.01em;">Year-to-date summary</div>
        <div class="tiny-note">Based on months included in your generated range.</div>
      </div>
      <div class="table-responsive mt-2">
        <table class="table table-sm table-bordered forecast-table">
          <thead>
            <tr>
              <th class="col-date">Year</th>
              <th class="col-calls">Calls</th>
              <th class="col-aht">AHT (sec)</th>
              <th class="col-fte">FTE Need<br>(No Shr.)</th>
              <th class="col-fte">FTE Need<br>(Shr.)</th>
              <th class="col-day">Days Included</th>
            </tr>
          </thead>
          <tbody>
            ${yearItems.map(y=>`
              <tr>
                <td><span class="pill">${escapeHtml(String(y.year))}</span></td>
                <td>${fmtInt(y.totalCalls||0)}</td>
                <td>${y.avgAht===null ? "" : fmtInt(Math.round(y.avgAht))}</td>
                <td>${y.avgFteNoShr===null ? "" : fmtInt(Math.round(y.avgFteNoShr))}</td>
                <td>${y.avgFteShr===null ? "" : fmtInt(Math.round(y.avgFteShr))}</td>
                <td>${fmtInt(y.daysIncluded||0)}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>
    </div>
  ` : "";

  const tableHtml = `
    <div class="forecast-wrap">
      ${ytdHtml}
      <div class="table-responsive">
        <table class="table table-sm table-bordered forecast-table">
          <thead>
            <tr>
              <th class="col-date">Month</th>
              <th class="col-calls">Calls</th>
              <th class="col-aht">AHT (sec)</th>
              <th class="col-fte">FTE Need<br>(No Shr.)</th>
              <th class="col-fte">FTE Need<br>(Shr.)</th>
              <th class="col-day">Days Included</th>
            </tr>
          </thead>
          <tbody>
            ${monthItems.map(mo=>`
              <tr>
                <td>${escapeHtml(mo.label || mo.monthKey)}</td>
                <td>${fmtInt(mo.summary.totalCalls||0)}</td>
                <td>${mo.summary.avgAht===null ? "" : fmtInt(Math.round(mo.summary.avgAht))}</td>
                <td>${mo.summary.avgFteNoShr===null ? "" : fmtInt(Math.round(mo.summary.avgFteNoShr))}</td>
                <td>${mo.summary.avgFteShr===null ? "" : fmtInt(Math.round(mo.summary.avgFteShr))}</td>
                <td>${fmtInt(mo.summary.daysIncluded||0)}</td>
              </tr>
            `).join("") || `<tr><td colspan="6" class="tiny-note">Generate a forecast to see monthly totals.</td></tr>`}
          </tbody>
        </table>
      </div>
    </div>
  `;
  el.innerHTML = tableHtml;
}

function getActiveMonthlyMethodKey(){
  const activeBtn = document.querySelector('#monthlyForecastTabs .nav-link.active');
  const target = activeBtn?.getAttribute('data-bs-target') || '#mTsTab';
  if(target === '#mRegTab') return 'reg';
  if(target === '#mAiTab') return 'ai';
  if(target === '#mOpenAiTab') return 'openai';
  return 'ts';
}

function renderMonthlyForecastActive(){
  // Renders monthly table based on CURRENT state.forecasts (so it stays in sync with Daily)
  const methodKey = getActiveMonthlyMethodKey();
  const rows = (state.forecasts && state.forecasts[methodKey]) ? state.forecasts[methodKey] : [];

  // Map method -> container id
  const map = { ts: "mTsTable", reg: "mRegTable", ai: "mAiTable", openai: "mOpenAiTable" };
  const cid = map[methodKey] || "mTsTable";

  // Always render into the active container
  renderMonthlyForecastTable(cid, rows);
}

// Re-render when switching monthly method tabs
document.addEventListener('shown.bs.tab', (ev)=>{
  try{
    const tgt = ev?.target;
    if(!tgt) return;
    const parent = tgt.closest && tgt.closest('#monthlyForecastTabs');
    if(parent){
      renderMonthlyForecastActive();
    }
    // Re-render when the Monthly top tab is activated
    const parentTop = tgt.closest && tgt.closest('#resultsTabsClean');
    if(parentTop){
      const t = tgt.getAttribute('data-bs-target');
      if(t === '#rt-monthly') renderMonthlyForecastActive();
    }
  }catch(e){}
});
function renderForecastTable(containerId, rows){
  const el = $(containerId);
  if(!el) return;
  if(!rows || !rows.length){
    el.innerHTML = `<div class="small-muted">No results.</div>`;
    return;
  }
  const summaryHtml = renderMonthlySummaryHTML(rows);
  const html = `
    <div class="forecast-wrap">
      ${summaryHtml}
      <div class="p-0">
        <table class="table table-sm table-bordered forecast-table">
          <thead>
            <tr>
              <th class="col-date">Date</th>
              <th class="col-day">Day</th>
              <th class="col-calls">Forecast Calls</th>
              <th class="col-aht">AHT (sec)</th>
              <th class="col-fte">FTE Need<br>(No Shr.)</th>
              <th class="col-fte">FTE Need<br>(Shr.)</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map(r=>`
              <tr>
                <td>${escapeHtml(fmtDateMDY(r.date))}</td>
                <td><span class="pill">${escapeHtml(dayShortFromISO(r.date))}</span></td>
                <td>${r.calls===null ? "" : fmtInt(r.calls)}</td>
                <td>${r.aht===null ? "" : fmtInt(r.aht)}</td>
                <td>${r.servers===null ? "" : fmtInt(r.servers)}</td>
                <td>${r.staffing===null ? "" : fmtInt(r.staffing)}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>
    </div>
  `;
  el.innerHTML = html;
}
/* ============================================================
   INTRADAY FORECAST (30-min) — mirrors Daily methods
   Uses: Daily forecast Calls + AHT, allocated by Intra Pattern (%)
   ============================================================ */
function intervalLabelFromIdx(i){
  const mins = START_MIN + (i * INTERVAL_MIN);
  return minutesToTime12(mins);
}

function buildIntradayForecastRowsForDate(methodKey, dateISO){
  const rowsDaily = (state.forecasts && state.forecasts[methodKey]) ? state.forecasts[methodKey] : [];
  if(!rowsDaily || !rowsDaily.length) return [];

  const iso = normalizeISODateString(dateISO);
  if(!iso) return [];

  const dayRow = rowsDaily.find(r => normalizeISODateString(r.date) === iso);
  if(!dayRow) return [];

  // Respect holiday blanks / closed days (daily row will already be blanked)
  const dailyCalls = (dayRow.calls===null || dayRow.calls===undefined) ? null : Number(dayRow.calls);
  const ahtSeconds = (dayRow.aht===null || dayRow.aht===undefined) ? null : Number(dayRow.aht);

  if(!isFinite(dailyCalls) || dailyCalls <= 0 || !isFinite(ahtSeconds) || ahtSeconds <= 0){
    return [];
  }

  const windows = buildHoopWindows();
  const hasAny = hasAnyHoopWindows(windows);

  const dk = dayKeyFromDowIdx(dowIdxFromISO(iso));
  const openIdx = hasAny ? getOpenIdxsForDay(dk, windows) : Array.from({length:INTERVALS},(_,i)=>i);

  if(!openIdx.length) return [];
  if(hasAny && !hasUsableIntradayForDay(dk, windows)) return [];

  const er = getErlangInputs();
  const svTargetPct = er.svTarget;
  const asaSeconds = er.asaTarget;
  const occTarget = clamp(er.occupancy || 85, 1, 100) / 100;
  const shrink = clamp(er.shrinkage || 0, 0, 99.9) / 100;

  const out = [];
  for(let i=0;i<INTERVALS;i++){
    const pct = state.intraday?.[dk]?.[i];

    // Outside HOOP or blank pattern cell => blank row
    if(pct === null || pct === undefined || !isFinite(Number(pct)) || Number(pct) <= 0){
      out.push({ interval: intervalLabelFromIdx(i), calls: null, aht: null, servers: null, staffing: null });
      continue;
    }

    const callsInterval = dailyCalls * (Number(pct) / 100);

    const N = requiredAgentsErlangC({
      callsInterval,
      intervalSeconds: INTERVAL_SECONDS,
      ahtSeconds,
      svTargetPct,
      asaSeconds
    });
    const servers = occTarget > 0 ? Math.ceil(N / occTarget) : N;
    const staffing = (1 - shrink) > 0 ? Math.ceil(servers / (1 - shrink)) : servers;

    out.push({
      interval: intervalLabelFromIdx(i),
      calls: callsInterval,
      aht: ahtSeconds,
      servers,
      staffing
    });
  }
  return out;
}

function renderIntradayForecastTable(containerId, rows, dateISO){
  const el = $(containerId);
  if(!el) return;

  if(!rows || !rows.length){
    el.innerHTML = `<div class="small-muted">No results.</div>`;
    return;
  }

  // Totals for visible (non-null) intervals
  const totalCalls = rows.reduce((a,r)=> a + (isFinite(Number(r.calls)) ? Number(r.calls) : 0), 0);
  const peakNoShrink = rows.reduce((a,r)=> Math.max(a, isFinite(Number(r.servers)) ? Number(r.servers) : 0), 0);
  const peakShrink = rows.reduce((a,r)=> Math.max(a, isFinite(Number(r.staffing)) ? Number(r.staffing) : 0), 0);

  const summary = `
    <div class="forecast-summary">
      <div class="sum-card">
        <div class="sum-title">Selected day</div>
        <div class="sum-grid">
          <div class="sum-k">Date</div><div class="sum-v">${escapeHtml(fmtDateMDY(dateISO))}</div>
          <div class="sum-k">Day</div><div class="sum-v">${escapeHtml(dayShortFromISO(dateISO))}</div>
        </div>
      </div>
      <div class="sum-card">
        <div class="sum-title">Intraday totals</div>
        <div class="sum-grid">
          <div class="sum-k">Calls (sum)</div><div class="sum-v">${fmtInt(totalCalls)}</div>
          <div class="sum-k">Peak FTE (No Shr.)</div><div class="sum-v">${fmtInt(peakNoShrink)}</div>
          <div class="sum-k">Peak FTE (Shr.)</div><div class="sum-v">${fmtInt(peakShrink)}</div>
        </div>
      </div>
    </div>
  `;

  const html = `
    <div class="forecast-wrap">
      ${summary}
      <div class="p-0">
        <table class="table table-sm table-bordered forecast-table">
          <thead>
            <tr>
              <th class="col-date">Interval</th>
              <th class="col-calls">Forecast Calls</th>
              <th class="col-aht">AHT<br>(sec)</th>
              <th class="col-fte">FTE Need<br>(No Shr.)</th>
              <th class="col-fte">FTE Need<br>(Shr.)</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map(r=>`
              <tr>
                <td><span class="pill">${escapeHtml(r.interval)}</span></td>
                <td>${r.calls===null ? "" : fmtInt(r.calls)}</td>
                <td>${r.aht===null ? "" : fmtInt(r.aht)}</td>
                <td>${r.servers===null ? "" : fmtInt(r.servers)}</td>
                <td>${r.staffing===null ? "" : fmtInt(r.staffing)}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>
    </div>
  `;
  el.innerHTML = html;
}

function renderAllIntradayForecastTables(){
  const dateISO = $('intraForecastDate')?.value;
  if(!dateISO){
    setMsg('intraForecastMsg', 'Select a date to view intraday forecast.');
    renderIntradayForecastTable('intraTsTable', [], "");
    renderIntradayForecastTable('intraRegTable', [], "");
    renderIntradayForecastTable('intraAiTable', [], "");
    renderIntradayForecastTable('intraOpenAiTable', [], "");
    return;
  }

  const methods = ['ts','reg','ai','openai'];
  const containers = {
    ts: 'intraTsTable',
    reg: 'intraRegTable',
    ai: 'intraAiTable',
    openai: 'intraOpenAiTable'
  };

  let any = false;
  methods.forEach(mk=>{
    const rows = buildIntradayForecastRowsForDate(mk, dateISO);
    if(rows && rows.length) any = true;
    renderIntradayForecastTable(containers[mk], rows, dateISO);
  });

  if(!any){
    setMsg('intraForecastMsg', 'No intraday results for this date/method. Generate forecasts first and ensure Intra Pattern exists inside HOOP.');
  }else{
    setMsg('intraForecastMsg', '');
  }
}

function initIntradayForecastUI(){
  const dateEl = $('intraForecastDate');
  if(!dateEl) return;

  const start = $('startDate')?.value;
  const end = $('endDate')?.value;

  // Limit picker to forecast range when available
  if(start) dateEl.min = start;
  if(end) dateEl.max = end;

  // Set default date if empty/outside range
  if(!dateEl.value){
    if(start) dateEl.value = start;
  }else{
    if(start && dateEl.value < start) dateEl.value = start;
    if(end && dateEl.value > end) dateEl.value = end;
  }

  // Render now
  renderAllIntradayForecastTables();
}

/* Update intraday forecast when the date changes */
document.addEventListener('change', (e)=>{
  if(e?.target?.id === 'intraForecastDate'){
    renderAllIntradayForecastTables();
  }
});


/* -------------------- CHART -------------------- */
let chartRef = null;
function renderChart(labels, series){
  const canvas = $('forecastChart');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartRef){ chartRef.destroy(); chartRef=null; }
  const datasets = [];
  if(series.ts) datasets.push({label:'Time Series (Calls)', data: series.ts});
  if(series.reg) datasets.push({label:'Regression (Calls)', data: series.reg});
  if(series.ai) datasets.push({label:'AI (Calls)', data: series.ai});
  if(series.openai) datasets.push({label:'OpenAI (Calls)', data: series.openai});
  chartRef = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      plugins: { legend: { display: true } },
      scales: { y: { beginAtZero: true } }
    }
  });
}

/* -------------------- REALTIME RECOMPUTE PIPELINE -------------------- */
function recomputeAndRenderMethod(methodKey){
  const base = state.baseForecasts?.[methodKey] || [];
  if(!base.length) return;

  let rows = base.map(r=>({
    date: r.date,
    calls: r.calls,
    aht: r.aht,
    servers: null,
    staffing: null
  }));

  rows = applyVolumeAssumptionsToCalls(rows, methodKey);
  rows = applyEventAdjustments(rows);
  rows = applyHolidayIntelAdjustments(rows);

  rows.forEach(r=>{
    if(r.calls===null || r.aht===null) return;
    const {servers, staffing} = computePeakStaffingForDay({
      dateISO: r.date,
      dailyCalls: Number(r.calls)||0,
      ahtSeconds: Number(r.aht)||0
    });
    r.servers = servers;
    r.staffing = staffing;
  });

  rows.forEach(r=>{
    if(r.calls!==null && r.calls!==undefined) r.calls = Math.max(0, Math.round(r.calls));
    if(r.aht!==null && r.aht!==undefined) r.aht = Math.round(r.aht);
  });

  state.forecasts[methodKey] = rows;
  if(methodKey === "ts"){
    const infoEl = $('tsModelInfo');
    if(infoEl && state.tsModelInfo){
      const cName = state.tsModelInfo.callsModel || "—";
      const aName = state.tsModelInfo.ahtModel || "—";
      const cMape = (state.tsModelInfo.callsMAPE!==null && state.tsModelInfo.callsMAPE!==undefined) ? state.tsModelInfo.callsMAPE.toFixed(1) : "—";
      const aMape = (state.tsModelInfo.ahtMAPE!==null && state.tsModelInfo.ahtMAPE!==undefined) ? state.tsModelInfo.ahtMAPE.toFixed(1) : "—";
      infoEl.innerHTML = `Auto-selected models — Calls: <strong>${escapeHtml(cName)}</strong> (MAPE ${escapeHtml(String(cMape))}%), AHT: <strong>${escapeHtml(aName)}</strong> (MAPE ${escapeHtml(String(aMape))}%)`;
    }else if(infoEl){
      infoEl.textContent = "";
    }
  }


  
  // Keep Monthly in sync
  renderMonthlyForecastActive();
if(methodKey === "ts") renderForecastTable("tsTable", rows);
  if(methodKey === "reg") renderForecastTable("regTable", rows);
  if(methodKey === "ai") renderForecastTable("aiTable", rows);
  if(methodKey === "openai") renderForecastTable("openaiTable", rows);

  
  if(methodKey === "ts") renderMonthlyForecastTable("mTsTable", rows);
  if(methodKey === "reg") renderMonthlyForecastTable("mRegTable", rows);
  if(methodKey === "ai") renderMonthlyForecastTable("mAiTable", rows);
  if(methodKey === "openai") renderMonthlyForecastTable("mOpenAiTable", rows);
const start = $('startDate')?.value;
  const end = $('endDate')?.value;
  const dates = (start && end) ? daterange(start, end) : rows.map(r=>r.date);

  const useHW = !!$('useHW')?.checked;
  const useReg = !!$('useRegression')?.checked;
  const useAI = !!$('useAI')?.checked;
  const useOpenAI = !!$('useOpenAI')?.checked;

  const series = {
    ts: useHW ? (state.forecasts.ts || []).map(r=> r.calls===null ? null : r.calls) : null,
    reg: useReg ? (state.forecasts.reg || []).map(r=> r.calls===null ? null : r.calls) : null,
    ai: useAI ? (state.forecasts.ai || []).map(r=> r.calls===null ? null : r.calls) : null,
    openai: useOpenAI ? (state.forecasts.openai || []).map(r=> r.calls===null ? null : r.calls) : null
  };
  renderChart(dates, series);

  
    initIntradayForecastUI();
const msgParts = [];
  msgParts.push(`Generated ${dates.length} forecast days.`);
  msgParts.push(`Closed / no-intraday days are blank for Calls, AHT, and FTE.`);
  msgParts.push(`Holiday dates are also blank.`);
  if(state.volumeAssumptions?.length) msgParts.push(`Volume assumptions applied: ${state.volumeAssumptions.length}`);
  const evCount = (state.events?.past?.length||0) + (state.events?.future?.length||0);
  if(evCount) msgParts.push(`Event intelligence applied: ${evCount} entries`);
  if(state.holidays?.length) msgParts.push(`Holidays: ${state.holidays.length}`);
  const out = $('outputs');
  if(out) out.innerHTML = `<div>${escapeHtml(msgParts.join(" • "))}</div>`;
}

/* -------------------- GENERATE -------------------- */
async function generateAll(){
  const btn = $('generateBtn');
  try{
    setMsg('genMsg','');

    if(!state.raw || !state.raw.daily || !state.raw.daily.length){
      setMsg('genMsg','Upload historical data first.');
      return;
    }

    const start = $('startDate')?.value;
    const end = $('endDate')?.value;
    if(!start || !end){
      setMsg('genMsg','Select a start date and end date.');
      return;
    }
    const dates = daterange(start, end);
    if(!dates.length){
      setMsg('genMsg','Invalid date range.');
      return;
    }

    const useHW = !!$('useHW')?.checked;
    const useReg = !!$('useRegression')?.checked;
    const useAI = !!$('useAI')?.checked;
    const useOpenAI = !!$('useOpenAI')?.checked;

    if(!useHW && !useReg && !useAI && !useOpenAI){
      setMsg('genMsg','Select at least one forecast method.');
      return;
    }

    if(btn) btn.disabled = true;
    showLoading('Training AI Model.');
    await sleep(30);

    applyHoopToIntraday();

    const hist = state.raw.daily.slice().sort((a,b)=>a.date-b.date);
    const histDatesISO = hist.map(r=>toISODate(r.date));
    const callsHist = hist.map(r=>Number(r.calls)||0);

    const fallbackAht = computeFallbackAHTSeconds(hist);
    const ahtHist = hist.map(r=>{
      const v = Number(r.aht)||0;
      return v>0 ? v : fallbackAht;
    });

    let tsCalls=null, regCalls=null, aiCalls=null, oaCalls=null;
    let tsAht=null, regAht=null, aiAht=null, oaAht=null;

    if(useHW){
      updateLoading('Generating Time Series (Auto)…');
      await sleep(20);
      const tsC = timeSeriesForecastAuto(callsHist, dates.length);
      const tsA = timeSeriesForecastAuto(ahtHist,   dates.length);
      tsCalls = tsC.forecast;
      tsAht   = tsA.forecast;

      // Enforce day-of-week realism (e.g., Saturdays) even when history is missing calendar days
      tsCalls = applyDowRatiosToForecast(tsCalls, dates, hist, "calls");
      // For AHT, keep model output by default (AHT often doesn't have strong DOW seasonality). If desired, uncomment:
      // tsAht = applyDowRatiosToForecast(tsAht, dates, hist, "aht");
      state.tsModelInfo = {
        callsModel: tsC.modelName,
        callsMAPE: tsC.mape,
        ahtModel: tsA.modelName,
        ahtMAPE: tsA.mape
      };
    }
    if(useReg){
      updateLoading('Generating Regression…');
      await sleep(20);
      regCalls = regressionForecastAdditive(callsHist, histDatesISO, dates);
      regAht   = regressionForecastAdditive(ahtHist,   histDatesISO, dates);
    }
    if(useAI){
      updateLoading('Training AI Model');
      await sleep(20);
      aiCalls = await aiForecastTF_1D(callsHist, histDatesISO, dates);

      updateLoading('AI Generating Forecast');
      await sleep(20);
      aiAht   = await aiForecastTF_1D(ahtHist,   histDatesISO, dates);
    }
    if(useOpenAI){
      updateLoading('Calling OpenAI via proxy…');
      await sleep(20);
      const res = await openAIForecastViaProxy({histDatesISO, callsHist, ahtHist, futureISOs: dates});
      oaCalls = res.calls;
      oaAht = res.aht;
    }

    function buildBaseRows(methodCalls, methodAht){
      let rows = dates.map((d,i)=>({
        date: d,
        calls: methodCalls ? methodCalls[i] : null,
        aht: methodAht ? methodAht[i] : null,
        servers: null,
        staffing: null
      }));

      rows.forEach(r=>{
        if(r.aht!==null && r.aht!==undefined){
          r.aht = clamp(r.aht, 60, 7200);
        }
      });

      rows = applyNonBusinessDayBlanks(rows);
      rows = applyHolidayBlanks(rows);
      return rows;
    }

    updateLoading('Rendering results…');
    await sleep(20);

    state.baseForecasts.ts  = useHW ? buildBaseRows(tsCalls, tsAht) : [];
    state.baseForecasts.reg = useReg ? buildBaseRows(regCalls, regAht) : [];
    state.baseForecasts.ai  = useAI ? buildBaseRows(aiCalls, aiAht) : [];
    state.baseForecasts.openai = useOpenAI ? buildBaseRows(oaCalls, oaAht) : [];

    if(useHW) recomputeAndRenderMethod("ts"); else { state.forecasts.ts = []; renderForecastTable("tsTable", []); }
    renderMonthlyForecastTable("mTsTable", []);
    if(useReg) recomputeAndRenderMethod("reg"); else { state.forecasts.reg = []; renderForecastTable("regTable", []); }
    renderMonthlyForecastTable("mRegTable", []);
    if(useAI) recomputeAndRenderMethod("ai"); else { state.forecasts.ai = []; renderForecastTable("aiTable", []); }
    renderMonthlyForecastTable("mAiTable", []);
    if(useOpenAI) recomputeAndRenderMethod("openai"); else { state.forecasts.openai = []; renderForecastTable("openaiTable", []); }
    renderMonthlyForecastTable("mOpenAiTable", []);

    const series = {
      ts: useHW ? (state.forecasts.ts || []).map(r=> r.calls===null ? null : r.calls) : null,
      reg: useReg ? (state.forecasts.reg || []).map(r=> r.calls===null ? null : r.calls) : null,
      ai: useAI ? (state.forecasts.ai || []).map(r=> r.calls===null ? null : r.calls) : null,
      openai: useOpenAI ? (state.forecasts.openai || []).map(r=> r.calls===null ? null : r.calls) : null
    };
    renderChart(dates, series);

    updateLoading('Done.');
    setMsg('genMsg','Done.');
    await sleep(600);
    hideLoading();
  }catch(err){
    console.error(err);
    setMsg('genMsg', 'Error: ' + (err?.message || String(err)));
    updateLoading('Error occurred.');
    await sleep(900);
    hideLoading();
  }finally{
    if(btn) btn.disabled = false;
  }
}


function getActiveDailyForecastKind(){
  const active = document.querySelector('#forecastTabs .nav-link.active');
  const target = active ? (active.getAttribute('data-bs-target') || active.getAttribute('data-target') || '') : '';
  if(target.includes('tsTab')) return 'ts';
  if(target.includes('regTab')) return 'reg';
  if(target.includes('aiTab') && !target.includes('openai')) return 'ai';
  if(target.includes('openaiTab')) return 'openai';
  // fallback: try by visible tab-pane
  const pane = document.querySelector('#forecastTabs ~ .tab-content .tab-pane.active, #forecastTabs ~ .tab-content .tab-pane.show.active');
  const pid = pane ? pane.id : '';
  if(pid === 'tsTab') return 'ts';
  if(pid === 'regTab') return 'reg';
  if(pid === 'aiTab') return 'ai';
  if(pid === 'openaiTab') return 'openai';
  return 'reg';
}

/* -------------------- INIT LOAD + WIRING -------------------- */
function init(){
  // Wire buttons safely (no null crashes)
  onClick('exportActiveBtn', ()=> exportForecastCSV(getActiveDailyForecastKind()));
  onClick('exportIntraActiveBtn', ()=> exportIntradayForecastCSV());
  onClick('exportMonthlyActiveBtn', ()=> exportMonthlyForecastCSV(getActiveMonthlyMethodKey()));
  onClick('saveVolBtn', saveVolumeAssumptions);
  onClick('addVolBtn', ()=>{
    const method = $('volMethod')?.value || "reg";
    const start = $('volStart')?.value;
    const end = $('volEnd')?.value;
    const pctRaw = $('volPct')?.value;

    if(!start || !end){
      setMsg('volMsg', 'Select a Start and End date for the volume assumption.');
      return;
    }
    const s = normalizeISODateString(start);
    const e = normalizeISODateString(end);
    if(!s || !e){
      setMsg('volMsg', 'Invalid date(s).');
      return;
    }
    let pct = Number(pctRaw);
    if(!isFinite(pct)){
      setMsg('volMsg', 'Enter a valid % change (example: 10 or -5).');
      return;
    }
    pct = clamp(pct, -99.9, 500);

    let aStart = s, aEnd = e;
    if(aEnd < aStart){ const tmp=aStart; aStart=aEnd; aEnd=tmp; }

    state.volumeAssumptions.push({method, start: aStart, end: aEnd, pct});
    renderVolumeAssumptions();
    setMsg('volMsg', 'Added (table updated).');
    recomputeAndRenderMethod(method);
  });

  onClick('saveOpenAISettingsBtn', saveOpenAISettings);

  onClick('saveErlangBtn', saveErlang);

  onClick('saveHoopBtn', saveHoops);

  onClick('addHoopBtn', ()=>{
    const el = $('hoopEntryCollapse');
    if(!el) return;
    const c = bootstrap.Collapse.getOrCreateInstance(el, {toggle:false});
    if(el.classList.contains('show')) c.hide();
    else c.show();
  });

  onClick('addHoopEntryBtn', ()=>{
    const keys = Array.from(hoopUi.selectedDayKeys);
    if(!keys.length){
      setMsg('hoopEntryMsg', 'Select at least one business day.');
      return;
    }
    const from = $('hoopStartSel')?.value;
    const to = $('hoopEndSel')?.value;
    if(!from || !to){
      setMsg('hoopEntryMsg', 'Select a start and end time.');
      return;
    }
    const dayStr = keys
      .slice()
      .sort((a,b)=> DAY_KEYS.indexOf(a) - DAY_KEYS.indexOf(b))
      .map(k => DAY_LABELS[DAY_KEYS.indexOf(k)])
      .join(", ");

    state.hoops.push({days: dayStr, from, to});
    renderHoops();
    applyHoopToIntraday();
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
    setMsg('hoopEntryMsg', 'Added entry (intraday + forecasts updated).');
  });

  onClick('clearHoopEntryBtn', clearHoopEntry);

  onClick('addHoliday', ()=>{
    const d = $('holidayDate')?.value;
    if(!d) return;
    const iso = normalizeISODateString(d);
    if(!iso) return;
    if(!state.holidays.includes(iso)) state.holidays.push(iso);
    renderHolidayList();
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });
  onClick('saveHolidaysBtn', saveHolidays);

  onClick('fillEvenBtn', ()=>{
    const windows = buildHoopWindows();
    const hasAny = hasAnyHoopWindows(windows);
    if(!hasAny){
      const pct = 100 / INTERVALS;
      DAY_KEYS.forEach(k=> state.intraday[k] = Array.from({length:INTERVALS}, ()=>pct));
    }else{
      DAY_KEYS.forEach(k=>{
        const openIdx = getOpenIdxsForDay(k, windows);
        state.intraday[k] = Array.from({length:INTERVALS}, ()=>null);
        if(openIdx.length){
          const even = 100 / openIdx.length;
          openIdx.forEach(i => state.intraday[k][i] = even);
        }
      });
    }
    refreshIntradayInputs();
    renderIntradayTotals();
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });
  onClick('clearAllBtn', ()=>{
    DAY_KEYS.forEach(k=> state.intraday[k] = Array.from({length:INTERVALS}, ()=>0));
    applyHoopToIntraday();
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });
  onClick('copyMonBtn', ()=>{
    const mon = (state.intraday.monday || Array.from({length:INTERVALS},()=>0)).slice(0,INTERVALS);
    DAY_KEYS.forEach(k=> state.intraday[k] = mon.slice());
    applyHoopToIntraday();
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });
  onClick('saveIntradayBtn', saveIntraday);
onClick('addPastEventBtn', ()=>{
    const p = analyzePastEventPreview();
    if(!p) return;
    const existingIdx = (state.events.past||[]).findIndex(x => (x.date===p.date && String(x.name||"").trim().toLowerCase()===String(p.name||"").trim().toLowerCase()));
    if(existingIdx >= 0) state.events.past[existingIdx] = p;
    else state.events.past.push(p);
    renderEventsUI();
    setMsg('pastEventMsg', 'Added past event (auto-analyzed & saved).');
    localStorage.setItem(LS.EVENTS, JSON.stringify(state.events));
    showPill('eventStatus');
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });
  onClick('addFutureEventBtn', ()=>{
    const refPastId = $('futureRefPast')?.value;
    if(!refPastId){
      setMsg('futureEventMsg', 'Select a reference past event first.');
      return;
    }
    const name = $('futureEventName')?.value || "Future Event";
    const dateISO = normalizeISODateString($('futureEventDate')?.value);
    if(!dateISO){
      setMsg('futureEventMsg', 'Select a valid future event date.');
      return;
    }
    const magnitudeRaw = $('futureEventMagnitude')?.value;
    const magnitude = isFinite(Number(magnitudeRaw)) ? Number(magnitudeRaw) : null;

    const spreadBefore = clamp(Number($('futureSpreadBefore')?.value)||0, 0, 30);
    const spreadAfter = clamp(Number($('futureSpreadAfter')?.value)||0, 0, 30);
    const decay = $('futureDecay')?.value || "linear";

    state.events.future.push({
      id: uid("future"),
      refPastId,
      name: String(name||"").trim() || "Future Event",
      date: dateISO,
      magnitude,
      spreadBefore,
      spreadAfter,
      decay
    });

    renderEventsUI();
    setMsg('futureEventMsg', 'Added future event (auto-applied & saved).');
    localStorage.setItem(LS.EVENTS, JSON.stringify(state.events));
    showPill('eventStatus');
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });
  onClick('saveEventsBtn', saveEvents);

  onClick('generateBtn', generateAll);
  /* Holiday Intelligence */
onClick('addPastHolidayBtn', ()=>{
    const p = analyzePastHolidayPreview();
    if(!p) return;
    const existingIdx = (state.holidayIntel.past||[]).findIndex(x => (String(x.name||"").trim().toLowerCase()===String(p.name||"").trim().toLowerCase()));
    if(existingIdx >= 0) state.holidayIntel.past[existingIdx] = p;
    else state.holidayIntel.past.push(p);
    saveHolidayIntel();
    renderHolidayIntelUI();
    setMsg('pastHolidayMsg', 'Added past holiday (learned impact stored).');
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });
  onClick('addFutureHolidayBtn', ()=>{
    const refPastId = $('futureHolidayRefPast')?.value;
    if(!refPastId){
      setMsg('futureHolidayMsg', 'Select a reference past holiday first.');
      return;
    }
    const name = $('futureHolidayName')?.value || 'Holiday';
    const dateISO = normalizeISODateString($('futureHolidayDate')?.value);
    if(!dateISO){
      setMsg('futureHolidayMsg', 'Select a future holiday date.');
      return;
    }
    const spreadBefore = safeNum($('futureHolidaySpreadBefore')?.value, 3);
    const spreadAfter  = safeNum($('futureHolidaySpreadAfter')?.value, 3);
    const decay = $('futureHolidayDecay')?.value || 'linear';

    const p = (state.holidayIntel.past||[]).find(x=>x.id===refPastId);
    const entry = {
      id: uid('fhol'),
      name: String(name).trim() || 'Holiday',
      dateISO,
      refPastId,
      refPastName: p ? p.name : '',
      spreadBefore: Math.max(0, Math.round(spreadBefore||0)),
      spreadAfter: Math.max(0, Math.round(spreadAfter||0)),
      decay
    };
    state.holidayIntel.future.push(entry);
    saveHolidayIntel();
    renderHolidayIntelUI();
    setMsg('futureHolidayMsg', 'Added future holiday. Forecast will apply the learned pattern.');
    ["ts","reg","ai","openai"].forEach(k=>recomputeAndRenderMethod(k));
  });

  // API Data Source
  onClick('apiTestBtn', apiTestConnection);
  onClick('apiFetchBtn', apiFetchAndApply);
  onClick('apiSaveBtn', apiSaveSettings);
  onClick('apiClearBtn', apiClearAll);
  onClick('apiRefreshPreviewBtn', renderApiPreview);

  // Data Source tab behavior
  document.querySelectorAll('#dataSourceTabs [data-bs-toggle="tab"]').forEach(btn=>{
    btn.addEventListener('shown.bs.tab', ()=>{
      syncDataSourceMode();
      renderApiPreview();
    });
  });

  // File input
  const fi = $('fileInput');
  if(fi) fi.addEventListener('change', handleFile);

  const fii = $('intradayFileInput');
  if(fii) fii.addEventListener('change', handleIntradayFile);

// Load saved
  loadHoops();
  loadErlang();
  loadHolidays();
  loadIntraday();
  loadVolumeAssumptions();
  loadEvents();
  loadHolidayIntel();
  loadOpenAISettings();
  apiLoadSettings();
  apiLoadCache();
  renderApiPreview();
  syncDataSourceMode();

  renderDaysDropdownMenu();
  populateTimeSelect('hoopStartSel', '07:00');
  populateTimeSelect('hoopEndSel', '20:00');
  updateDaysDropdownLabel();

  buildIntradayTable();
  renderHolidayList();
  renderHoops();
  renderVolumeAssumptions();
  renderEventsUI();

  applyHoopToIntraday();

  // Toggle labels for collapses
  document.querySelectorAll('[data-bs-toggle="collapse"]').forEach(btn=>{
    const targetSel = btn.getAttribute('data-bs-target');
    if(!targetSel) return;
    const tgt = document.querySelector(targetSel);
    if(!tgt) return;
    const txt = btn.querySelector('.toggle-text');
    const setLabel = ()=>{
      const expanded = btn.getAttribute('aria-expanded') === 'true';
      if(txt) txt.textContent = expanded ? 'Minimize' : 'Maximize';
    };
    setLabel();
    tgt.addEventListener('shown.bs.collapse', setLabel);
    tgt.addEventListener('hidden.bs.collapse', setLabel);
    btn.addEventListener('click', ()=> setTimeout(setLabel, 0));
  });
}

// Run after DOM is ready (prevents missing-element crashes)
document.addEventListener('DOMContentLoaded', init);
</script></body>
</html>